[{"title":"17.电话号码的字母组合","date":"2020-01-04T16:00:00.000Z","path":"posts/8ffbed9b.html","text":"题目要求给定一个包含2到9（含2-9）数字的字符串，请返回该数字可以表示的所有可能的字母组合。 下面给出了数字到字母的映射（就像在电话按钮上一样）。请注意，1不会映射到任何字母。 注意：尽管以上答案按字典顺序排列，但您的答案可以按您想要的任何顺序排列。 题目示例 示例:12Input: \"23\"Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 解题思路解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { private String letterMap[] = { \" \", //0 \"\", //1 \"abc\", //2 \"def\", //3 \"ghi\", //4 \"jkl\", //5 \"mno\", //6 \"pqrs\", //7 \"tuv\", //8 \"wxyz\" //9 }; private ArrayList&lt;String&gt; res; public List&lt;String&gt; letterCombinations(String digits) { res = new ArrayList&lt;String&gt;(); if(digits.equals(\"\")) return res; findCombination(digits, 0, \"\"); return res; } // s中保存了此时从digits[0...index-1]翻译得到的一个字母字符串 // 寻找和digits[index]匹配的字母, 获得digits[0...index]翻译得到的解 private void findCombination(String digits, int index, String s){ // System.out.println(index + \" : \" + s); if(index == digits.length()) { res.add(s); // System.out.println(\"get \" + s + \" , return\"); return; } Character c = digits.charAt(index); assert c.compareTo('0') &gt;= 0 &amp;&amp; c.compareTo('9') &lt;= 0 &amp;&amp; c.compareTo('1') != 0; String letters = letterMap[c - '0']; for(int i = 0; i &lt; letters.length(); i++) { // System.out.println(\"digits[\" + index + \"] = \" + c + \" , use \" + letters.charAt(i)); findCombination(digits, index+1, s + letters.charAt(i)); } return; }} 题目来源LeetCode-17.电话号码的字母组合 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"recursion","slug":"recursion","permalink":"https://algo.zeffon.cn/tags/recursion/"}]},{"title":"236.二叉树的最近公共祖先","date":"2020-01-03T16:00:00.000Z","path":"posts/499bd744.html","text":"题目要求给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 题目示例 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 解题思路解题代码12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) { return root; } if(root == p || root == q) { return root; } TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left != null &amp;&amp; right != null) { return root; } else if(left != null) { return left; } else if(right != null) { return right; } return null; }} 题目来源LeetCode-236.二叉树的最近公共祖先 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"230.二叉搜索树中第K小的元素","date":"2020-01-03T05:11:29.000Z","path":"posts/e7a72fb5.html","text":"题目要求给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明:你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 进阶：如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？ 题目示例 示例 1: 1234567输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2输出: 1 示例 2: 123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1输出: 3 解题思路递归查找k元素，借助于index 解题代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { // 标记k的计数器，当k == index 则表示找到该元素 private int index; public int kthSmallest(TreeNode root, int k) { index = 0; return kthSmallestNode(root, k).val; } // 寻找到k对应的节点 private TreeNode kthSmallestNode(TreeNode node, int k) { if(node == null) { return null; } TreeNode res = kthSmallestNode(node.left, k); if(res != null) { return res; } index++; if(index == k) { return node; } return kthSmallestNode(node.right, k); } } 题目来源LeetCode-230.二叉搜索树中第K小的元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"108. 将有序数组转换为二叉搜索树","date":"2020-01-02T04:55:29.000Z","path":"posts/4970e84b.html","text":"题目要求将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 题目示例 示例:123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \\ -3 9 / / -10 5 解题思路解题代码1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode sortedArrayToBST(int[] nums) { if(nums.length == 0) { return null; } return buildTree(nums, 0, nums.length - 1); } private TreeNode buildTree(int[] nums, int l, int r) { if(l &gt; r) { return null; } // 中间值 int mid = l + (r - l) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = buildTree(nums, l, mid - 1); root.right = buildTree(nums, mid + 1, r); return root; }} 题目来源LeetCode-108.将有序数组转换为二叉搜索树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"450.删除二叉搜索树中的节点","date":"2020-01-01T04:29:10.000Z","path":"posts/b016ebc2.html","text":"题目要求给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 说明：要求算法时间复杂度为 O(h)，h 为树的高度。 题目示例 示例:1234567891011121314151617181920212223242526root = [5,3,6,2,4,null,7]key = 3 5 / \\ 3 6 / \\ \\2 4 7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 / \\ 4 6 / \\2 7另一个正确答案是 [5,2,6,null,4,null,7]。 5 / \\ 2 6 \\ \\ 4 7 解题思路解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode deleteNode(TreeNode root, int key) { if(root == null) { return null; } if(key &lt; root.val) { root.left = deleteNode(root.left, key); return root; } if(key &gt; root.val) { root.right = deleteNode(root.right, key); return root; } if(root.right == null) { return root.left; } if(root.left == null) { return root.right; } TreeNode p = root; TreeNode min = root.right; while(min.left != null) { p = min; min = min.left; } root.val = min.val; root.right = deleteMinNode(root.right); return root; } private TreeNode deleteMinNode(TreeNode root) { if(root.left == null) { return root.right; } root.left = deleteMinNode(root.left); return root; }} 题目来源LeetCode-450.删除二叉搜索树中的节点 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"98.验证二叉搜索树","date":"2019-12-30T16:00:00.000Z","path":"posts/d394199d.html","text":"题目要求给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 题目示例 示例 1: 12345输入: 2 / \\ 1 3输出: true 示例 2: 123456789输入: 5 / \\ 1 4&nbsp; / \\&nbsp; 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。&nbsp; 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路 利用二叉树的性质：左节点小于父节点、右节点大于父节点 递归往某一节点的左右节点进行遍历 解题代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isValidBST(TreeNode root) { return isValidBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE); } private boolean isValidBST(TreeNode node, int min, int max){ if(node == null) { return true; } if(node.val &lt; min || node.val &gt; max) { return false; } if(node.left != null &amp;&amp; node.left.val &gt;= node.val) { return false; } if(node.right != null &amp;&amp; node.right.val &lt;= node.val) { return false; } return isValidBST(node.left, min, node.val - 1) &amp;&amp; isValidBST(node.right, node.val + 1, max); }} 题目来源LeetCode-98.验证二叉搜索树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"235.二叉搜索树的最近公共祖先","date":"2019-12-29T16:00:00.000Z","path":"posts/dc7bab14.html","text":"题目要求给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 说明:所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉搜索树中。 题目示例 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 解题思路 利用二叉树的性质：左节点小于父节点、右节点大于父节点 递归往某一节点的左右节点进行遍历 解题代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(p == null || q == null) throw new IllegalArgumentException(\"p or q can not be null.\"); if(root == null) return null; if(p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q); if(p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q); return root; }} 题目来源LeetCode-235.二叉搜索树的最近公共祖先 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"437.路径总和 III","date":"2019-12-28T16:00:00.000Z","path":"posts/7d55a6ba.html","text":"题目要求给定一个二叉树，它的每个结点都存放着一个整数值。找出路径和等于给定数值的路径总数。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 题目示例 示例:123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 解题思路解题代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int pathSum(TreeNode root, int sum) { if(root == null) return 0; return findPath(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum); } private int findPath(TreeNode root, int sum) { if(root == null) return 0; int res = 0; if(root.val == sum) res += 1; res += findPath(root.left, sum - root.val); res += findPath(root.right, sum - root.val); return res; }} 题目来源LeetCode-437.路径总和 III document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"129.求根到叶子节点数字之和","date":"2019-12-27T16:00:00.000Z","path":"posts/ab15f1b5.html","text":"题目要求给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。计算从根到叶子节点生成的所有数字之和。 说明:叶子节点是指没有子节点的节点。 题目示例 示例 1: 123456789输入: [1,2,3] 1 / \\ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2: 123456789101112输入: [4,9,0,5,1] 4 / \\ 9 0&nbsp;/ \\5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 解题思路解题代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { private int sumNum = 0; public int sumNumbers(TreeNode root) { if(root == null) { return 0; } dfs(root, 0); return sumNum; } private void dfs(TreeNode root, int sum) { if(root.left == null &amp;&amp; root.right == null) { sumNum += sum + root.val; } if(root.left != null) { dfs(root.left, sum * 10 + root.val * 10); } if(root.right != null) { dfs(root.right, sum * 10 + root.val * 10); } }} 题目来源LeetCode-129.求根到叶子节点数字之和 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"113.路径总和 II","date":"2019-12-26T16:00:00.000Z","path":"posts/1504ba16.html","text":"题目要求给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明:叶子节点是指没有子节点的节点。 题目示例 示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 返回:1234[ [5,4,11,2], [5,8,4,5]] 解题思路解题代码1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) { return res; } dfs(root, sum, res, new ArrayList&lt;Integer&gt;()); return res; } private void dfs(TreeNode root, int sum, List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; tmp) { if (root == null) { return; } tmp.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) { res.add(new ArrayList&lt;&gt;(tmp)); } dfs(root.left, sum - root.val, res, tmp); dfs(root.right, sum - root.val, res, tmp); tmp.remove(tmp.size() - 1); }} 题目来源LeetCode-113.路径总和 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"257.二叉树的所有路径","date":"2019-12-25T16:00:00.000Z","path":"posts/6110f261.html","text":"题目要求给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明:叶子节点是指没有子节点的节点。 题目示例 示例:1234567891011输入: 1 / \\2 3 \\ 5输出: [\"1-&gt;2-&gt;5\", \"1-&gt;3\"]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3、 解题思路解题代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; if(root.left == null &amp;&amp; root.right == null) { res.add(Integer.toString(root.val)) return res; } List&lt;String&gt; leftPaths = binaryTreePaths(root.left); for(String s : leftPaths){ StringBuilder sb = new StringBuilder(Integer.toString(root.val)); sb.append(\"-&gt;\"); sb.append(s); res.add(sb.toString()); } List&lt;String&gt; rightPaths = binaryTreePaths(root.right); for(String s : rightPaths) { StringBuilder sb = new StringBuilder(Integer.toString(root.val)); sb.append(\"-&gt;\"); sb.append(s); res.add(sb.toString()); } return res; }} 题目来源LeetCode-257.二叉树的所有路径 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"404.左叶子之和","date":"2019-12-24T16:00:00.000Z","path":"posts/724fee56.html","text":"题目要求计算给定二叉树的所有左叶子之和。 题目示例 示例:1234567 3 / \\ 9 20 / \\ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 解题思路解题代码12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int sumOfLeftLeaves(TreeNode root) { if(root == null) { return 0; } return dfs(root, false); } public int dfs(TreeNode node, boolean isLeft) { if(node.left == null &amp;&amp; node.right == null) { if(isLeft) { return node.val; } return 0; } int res = 0; if(node.left != null) { res += dfs(node.left, true); } if(node.right != null) { res += dfs(node.right, false); } return res; }} 题目来源LeetCode-404.左叶子之和 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"112.路径总和","date":"2019-12-23T16:00:00.000Z","path":"posts/d9911796.html","text":"题目要求给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明:叶子节点是指没有子节点的节点。 题目示例 示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 解题思路 递归解法 时间复杂度: O(n), n为树的节点个数 空间复杂度: O(h), h为树的高度 解题代码123456789101112131415161718/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean hasPathSum(TreeNode root, int sum) { if(root == null) return false; if(root.left == null &amp;&amp; root.right == null) return sum == root.val; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); }} 题目来源LeetCode-112.路径总和 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"110.平衡二叉树","date":"2019-12-22T16:00:00.000Z","path":"posts/3f648717.html","text":"题目要求给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 题目示例 示例 1:给定二叉树 [3,9,20,null,null,15,7] 12345 3 / \\9 20 / \\ 15 7 返回 true 。 示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4] 1234567 1 / \\ 2 2 / \\ 3 3 / \\4 4 返回 false 。 解题思路解题代码1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isBalanced(TreeNode root) { return depth(root) != -1; } public int depth(TreeNode root) { if(root == null) { return 0; } int left = depth(root.left); if(left == -1) { return -1; } int right = depth(root.right); if(right == -1) { return -1; } return Math.abs(left - right) &lt; 2 ? Math.max(left, right) + 1 : -1; }} 题目来源LeetCode-110.平衡二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"222.完全二叉树的节点个数","date":"2019-12-21T16:00:00.000Z","path":"posts/1f5935ac.html","text":"题目要求给出一个完全二叉树，求出该树的节点个数。 说明:完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 题目示例 示例 1:12345678输入: 1 / \\ 2 3 / \\ /4 5 6输出: 6 解题思路解题代码1234567891011121314151617/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int countNodes(TreeNode root) { if(root == null) { return 0; } return countNodes(root.left) + countNodes(root.right) + 1; }} 题目来源LeetCode-222.完全二叉树的节点个数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"101.对称二叉树","date":"2019-12-20T16:00:00.000Z","path":"posts/a1f254ad.html","text":"题目要求给定一个二叉树，检查它是否是镜像对称的。 说明:如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 题目示例 示例 1:二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 示例 2:但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \\2 2 \\ \\ 3 3 解题思路解题代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isSymmetric(TreeNode root) { if(root == null) { return true; } return dfs(root.left, root.right); } public boolean dfs(TreeNode p, TreeNode q) { if(p == null &amp;&amp; q == null) { return true; } if(p == null || q == null) { return false; } if(p.val != q.val) { return false; } return dfs(p.left, q.right) &amp;&amp; dfs(p.right, q.left); }} 题目来源LeetCode-101.对称二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"100.相同的树","date":"2019-12-19T16:00:00.000Z","path":"posts/a0031ca0.html","text":"题目要求给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 题目示例 示例 1: 1234567输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解题思路解题代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if(p == null &amp;&amp; q == null) { return true; } if(p == null || q == null) { return false; } if(p.val != q.val) { return false; } return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); }} 题目来源LeetCode-100.相同的树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"226.翻转二叉树","date":"2019-12-18T16:00:00.000Z","path":"posts/8ad59f22.html","text":"题目要求翻转一棵二叉树。 备注:这个问题是受到 Max Howell 的 原问题 启发的 ： 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 题目示例 示例:输入：12345 4 / \\ 2 7 / \\ / \\1 3 6 9 输出：12345 4 / \\ 7 2 / \\ / \\9 6 3 1 解题思路解题代码123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public TreeNode invertTree(TreeNode root) { if(root ==null) return null; TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; }} 题目来源LeetCode-226.翻转二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"111.二叉树的最小深度","date":"2019-12-18T01:23:20.000Z","path":"posts/2db490e1.html","text":"题目要求给定一个二叉树，找出其最大深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明:叶子节点是指没有子节点的节点。 题目示例 示例:给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \\9 20 / \\ 15 7 返回它的最小深度 2. 解题思路 递归解法 判断根root为空，则返回0 递归其的左右节点，注意层数需要+1 时间复杂度: O(n), n是树中的节点个数; 空间复杂度: O(h), h是树的高度 解题代码1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int minDepth(TreeNode root) { if(root == null) { return 0; } if(root.left == null &amp;&amp; root.right != null) { return 1 + minDepth(root.right); } if(root.right == null &amp;&amp; root.left != null) { return 1 + minDepth(root.left); } return 1 + Math.min(minDepth(root.left), minDepth(root.right)); }} 题目来源LeetCode-111.二叉树的最小深度 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"104. 二叉树的最大深度","date":"2019-12-16T16:00:00.000Z","path":"posts/ff0c5d84.html","text":"题目要求给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明：叶子节点是指没有子节点的节点。 题目示例 示例:给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \\9 20 / \\ 15 7 返回它的最大深度 3 。 解题思路 递归解法 判断根root为空，则返回0 递归其的左右节点，注意层数需要+1 时间复杂度: O(n), n是树中的节点个数; 空间复杂度: O(h), h是树的高度 解题代码12345678910111213141516/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int maxDepth(TreeNode root) { if(root == null) return 0; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); }} 题目来源LeetCode-104.二叉树的最大深度 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"102.二叉树的层次遍历","date":"2019-12-12T16:00:00.000Z","path":"posts/e79997f0.html","text":"题目要求给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 题目示例 示例:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 示例 3: 12输入: \"(]\"输出: false 解题思路 采用先进先出的队列和二叉树 由于题目返回的是List&lt;List&lt;Integer&gt;&gt;，定义ArrayList&lt;List&lt;Integer&gt;&gt;的返回结果res。并且判断root为null，直接返回。 定义先入先出的队列queue,存储的是数据对将节点与层数绑成一对 – LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt;。 将二叉树根节点root和层数0放进队列中，遍历队列。获取到队尾的Pair的Key节点的值和Value层数level，如果level == res.size(),则需要再开新的一层。否则的话，将节点的层数和节点值添加到res。再将该节点的左右节点分别入队。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */import javafx.util.Pair;class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(root == null) return res; // 我们使用LinkedList来做为我们的先入先出的队列 LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; queue = new LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt;(); queue.addLast(new Pair&lt;TreeNode, Integer&gt;(root, 0)); while(!queue.isEmpty()){ Pair&lt;TreeNode, Integer&gt; front = queue.removeFirst(); TreeNode node = front.getKey(); int level = front.getValue(); if(level == res.size()) res.add(new ArrayList&lt;Integer&gt;()); assert level &lt; res.size(); res.get(level).add(node.val); if(node.left != null) queue.addLast(new Pair&lt;TreeNode, Integer&gt;(node.left, level + 1)); if(node.right != null) queue.addLast(new Pair&lt;TreeNode, Integer&gt;(node.right, level + 1); } return res; }} 题目来源LeetCode-102.二叉树的层次遍历 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"queue","slug":"queue","permalink":"https://algo.zeffon.cn/tags/queue/"},{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"}]},{"title":"341.扁平化嵌套列表迭代器","date":"2019-12-11T16:00:00.000Z","path":"posts/b4c84e9e.html","text":"题目要求给定一个嵌套的整型列表。设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的项或者为一个整数，或者是另一个列表。 题目示例 示例 1: 123输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用&nbsp;next 直到&nbsp;hasNext 返回false，next&nbsp;返回的元素的顺序应该是: [1,1,2,1,1]。 示例 2: 123输入: [1,[4,[6]]]输出: [1,4,6]解释: 通过重复调用&nbsp;next&nbsp;直到&nbsp;hasNext 返回false，next&nbsp;返回的元素的顺序应该是: [1,4,6]。 解题思路利用递归，nestedList遍历到无嵌套数组时，直接添加进自定义一维数组中；遍历到嵌套数组时，进行递归调用 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger { * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * } */public class NestedIterator implements Iterator&lt;Integer&gt; { private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); private int pointer = 0; public NestedIterator(List&lt;NestedInteger&gt; nestedList) { resolve(nestedList); } public void resolve(List&lt;NestedInteger&gt; nestedList) { for (int i = 0 ; i &lt; nestedList.size() ; i++) { NestedInteger t = nestedList.get(i); if (t.isInteger()) { list.add(t.getInteger()); } else { resolve(t.getList()); } } } @Override public Integer next() { return list.get(pointer++); } @Override public boolean hasNext() { return pointer &lt; list.size(); }}/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */ 题目来源LeetCode-341.扁平化嵌套列表迭代器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"stack","slug":"stack","permalink":"https://algo.zeffon.cn/tags/stack/"}]},{"title":"94. 二叉树的中序遍历","date":"2019-12-10T16:00:00.000Z","path":"posts/5b2d6749.html","text":"题目要求给定一个二叉树，返回它的中序遍历。 进阶递归解决方案是微不足道的，可以迭代吗？ 题目示例 示例 1: 1234567输入: [1,null,2,3] 1 \\ 2 / 3输出: [1,3,2] 解题思路解题代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; inorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) { return res; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()) { if(cur != null) { stack.push(cur); cur = cur.left; } else { cur = stack.pop(); res.add(cur.val); cur = cur.right; } } return res; }} 题目来源LeetCode-94. 二叉树的中序遍历 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"},{"name":"stack","slug":"stack","permalink":"https://algo.zeffon.cn/tags/stack/"}]},{"title":"145.二叉树后序遍历","date":"2019-12-10T16:00:00.000Z","path":"posts/856309e3.html","text":"题目要求给定一个二叉树，返回其节点值的后序遍历。 进阶递归解决方案是微不足道的，可以迭代吗？ 题目示例 示例 1: 1234567Input: [1,null,2,3] 1 \\ 2 / 3Output: [3,2,1] 解题思路解题代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) { return res; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; TreeNode cur = root; while(cur != null || !stack.isEmpty()) { if(cur != null) { stack.push(cur); cur = cur.left; } else { cur = stack.pop(); if(cur.right == null || pre == cur.right){ res.add(cur.val); pre = cur; cur = null; } else{ stack.push(cur); cur = cur.right; } } } return res; }} 题目来源LeetCode-145.二叉树后序遍历 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"},{"name":"stack","slug":"stack","permalink":"https://algo.zeffon.cn/tags/stack/"}]},{"title":"144.二叉树前序遍历","date":"2019-12-09T16:00:00.000Z","path":"posts/209ca27a.html","text":"题目要求给定一个二叉树，返回其节点值的前序遍历。 进阶递归解决方案是微不足道的，可以迭代吗？ 题目示例 示例 1: 1234567Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3] 解题思路解题代码12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null) { return res; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty()) { if(cur != null) { res.add(cur.val); stack.push(cur); cur = cur.left; } else { cur = stack.pop(); cur = cur.right; } } return res; }} 题目来源LeetCode-144.二叉树前序遍历 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"binary Search Tree","slug":"binary-Search-Tree","permalink":"https://algo.zeffon.cn/tags/binary-Search-Tree/"},{"name":"stack","slug":"stack","permalink":"https://algo.zeffon.cn/tags/stack/"}]},{"title":"71.简化路径","date":"2019-12-08T16:00:00.000Z","path":"posts/c58b848.html","text":"题目要求给定文件的绝对路径（Unix风格），请简化它。或者换句话说，将其转换为规范路径。 在UNIX样式的文件系统中，句点.引用当前目录。此外，双倍时间..会将目录上移。有关更多信息，请参见： Linux / Unix中的绝对路径与相对路径请注意，返回的规范路径必须始终以斜杠开头/，并且两个目录名称之间必须只有一个斜杠。最后的目录名称（如果存在不得以/结尾。同样，规范路径必须是代表绝对路径的最短字符串。 题目示例 示例 1: 123Input: \"/home/\"Output: \"/home\"Explanation: Note that there is no trailing slash after the last directory name. 示例 2: 123Input: \"/../\"Output: \"/\"Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. 示例 3: 123Input: \"/home//foo/\"Output: \"/home/foo\"Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. 示例 4: 12Input: \"/a/./b/../../c/\"Output: \"/c\" 示例 5: 12Input: \"/a/../../b/../c//.//\"Output: \"/c\" 示例 6: 12Input: \"/a//b////c/d//././/..\"Output: \"/a/b/c\" 解题思路解题代码1234567891011121314151617181920212223242526class Solution { public String simplifyPath(String path) { String[] words = path.split(\"/\"); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for(String c : words) { if(\"\".equals(c) || \".\".equals(c) || (\"..\".equals(c) &amp;&amp; stack.isEmpty())) { continue; } else if(\"..\".equals(c) &amp;&amp; !stack.isEmpty()) { stack.pop(); } else { stack.push(\"/\" + c); } } if(stack.isEmpty()) { return \"/\"; } String res = \"\"; for(String s: stack) { res += s; } return res; }} 题目来源LeetCode-71.简化路径 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"stack","slug":"stack","permalink":"https://algo.zeffon.cn/tags/stack/"}]},{"title":"150.逆波兰表达式求值","date":"2019-12-07T16:00:00.000Z","path":"posts/8533a662.html","text":"题目要求根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 题目示例 示例 1: 123输入: [\"2\", \"1\", \"+\", \"3\", \"*\"]输出: 9解释: ((2 + 1) * 3) = 9 示例 2: 123输入: [\"4\", \"13\", \"5\", \"/\", \"+\"]输出: 6解释: (4 + (13 / 5)) = 6 示例 3: 12345678910输入: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路解题代码123456789101112131415161718192021222324252627class Solution { public int evalRPN(String[] tokens) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(String s : tokens) { if(s.equals(\"+\") || s.equals(\"-\") || s.equals(\"*\") || s.equals(\"/\")) { int a = stack.pop(); int b = stack.pop(); if(s.equals(\"+\")) { stack.push(b + a); } if(s.equals(\"-\")) { stack.push(b - a); } if(s.equals(\"*\")) { stack.push(b * a); } if(s.equals(\"/\")) { stack.push(b / a); } } else { stack.push(Integer.parseInt(s)); } } return stack.peek(); }} 题目来源LeetCode-150.逆波兰表达式求值 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"stack","slug":"stack","permalink":"https://algo.zeffon.cn/tags/stack/"}]},{"title":"20.有效的括号","date":"2019-12-06T16:00:00.000Z","path":"posts/f8383d11.html","text":"题目要求 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意 空字符串可被认为是有效字符串。 题目示例 示例 1: 12输入: \"()\"输出: true 示例 2: 12输入: \"()[]{}\"输出: true 示例 3: 12输入: \"(]\"输出: false 解题思路本题使用的到数据结构–栈。需要引进Stack import java.util.Stack; 先实例化Stack对象1Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); 根据字符串s的长度遍历其的元素，从第一个判断是否是属于 (、{、[ 任意一种属于左开闭的括号，若是则让它进栈1stack.push(c); 如果不是属于左开闭的括号，先判断当前栈是否为空，若为空直接返回false 获取栈顶的元素1char topChar = stack.pop(); 再来判断栈顶元素与遍历的元素是否一致123456789if (c == ')' &amp;&amp; topChar != '('){ return false;}if (c == ']' &amp;&amp; topChar != '['){ return false;}if (c == '}' &amp;&amp; topChar != '{'){ return false;} 最后若for循环遍历没有return false，不能急得return true。因为还要判断栈是否有元素，只有为空时才能return true。1return stack.isEmpty(); 解题代码123456789101112131415161718192021222324252627class Solution { public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if(c == '(' || c == '{' || c == '[') { stack.push(c); } else { if(stack.isEmpty()) { return false; } char top = stack.pop(); if(c == ')' &amp;&amp; top != '(') { return false; } if(c == ']' &amp;&amp; top != '[') { return false; } if(c == '}' &amp;&amp; top != '{') { return false; } } } return stack.isEmpty(); }} 题目来源LeetCode-20.有效的括号 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"stack","slug":"stack","permalink":"https://algo.zeffon.cn/tags/stack/"}]},{"title":"234.回文链表","date":"2019-12-05T16:00:00.000Z","path":"posts/368b4e07.html","text":"题目要求请判断一个链表是否为回文链表。 题目示例示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 解题思路解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public boolean isPalindrome(ListNode head) { if(head == null || head.next == null) { return true; } ListNode slow = head, fast = head; while(fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } slow.next = reverse(slow.next); slow = slow.next; ListNode cur = head; while(slow != null) { if(cur.val != slow.val) { return false; } else { slow = slow.next; cur = cur.next; } } return true; } private ListNode reverse(ListNode head) { if(head == null || head.next == null) { return head; } ListNode pre = head; ListNode cur = head.next; ListNode next = cur.next; head.next = null; while(true) { cur.next = pre; pre = cur; cur = next; if(cur == null) { break; } next = cur.next; } return pre; }} 题目来源LeetCode-234.回文链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"143.重排链表","date":"2019-12-04T16:00:00.000Z","path":"posts/1648e7be.html","text":"题目要求给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 题目示例示例 1: 1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public void reorderList(ListNode head) { if (head != null) { //找到链表中点。 ListNode slow = head, fast = head; while (fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } //断开后，逆转后半部分 fast = slow.next; //从中间断开 slow.next = null; ListNode pre = null, tmp = null; while (fast != null) { tmp = fast.next; fast.next = pre; pre = fast; fast = tmp; } //同时从两端遍历，向前半段中加入节点 slow, pre slow = head; while (pre != null) { tmp = slow.next; slow.next = pre; slow = slow.next; pre = pre.next; slow.next = tmp; slow = slow.next; } } }} 题目来源LeetCode-143.重排链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"61.旋转链表","date":"2019-12-02T16:00:00.000Z","path":"posts/d11874bc.html","text":"题目要求给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 题目示例示例 1: 12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步:&nbsp;0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步:&nbsp;2-&gt;0-&gt;1-&gt;NULL 解题思路解题代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null) { return null; } int len = get_len(head); k = k % len; ListNode end = head; for(int i = 0; i &lt; k; i++) { end = end.next; } ListNode start = head; while(end.next != null) { start = start.next; end = end.next; } end.next = head; head = start.next; start.next = null; return head; } private int get_len(ListNode head) { int res = 0; while(head != null) { res++; head = head.next; } return res; }} 题目来源LeetCode-61.旋转链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"148.排序链表","date":"2019-12-01T16:00:00.000Z","path":"posts/b80f3b8e.html","text":"题目要求在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 题目示例示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode sortList(ListNode head) { if(head == null || head.next == null) { return head; } ListNode slow = head; ListNode fast = head.next; while(fast != null &amp;&amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } ListNode head2 = slow.next; slow.next = null; head = sortList(head); head2 = sortList(head2); return merge(head, head2); } private ListNode merge(ListNode a, ListNode b) { ListNode dummyHead = new ListNode(0); ListNode p1 = a, p2 = b, p = dummyHead; while(p1 != null &amp;&amp; p2 != null) { if(p1.val &lt; p2.val) { p.next = p1; p1 = p1.next; p = p.next; p.next = null; } else { p.next = p2; p2 = p2.next; p = p.next; p.next = null; } } if(p1 != null) { p.next = p1; } if(p2 != null) { p.next = p2; } return dummyHead.next; }} 题目来源LeetCode-148.排序链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"147.对链表进行插入排序","date":"2019-11-30T16:00:00.000Z","path":"posts/977ced29.html","text":"题目要求对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法：插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。 题目示例示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路解题代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode insertionSortList(ListNode head) { if(head == null || head.next == null) { return head; } ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode pre = dummyHead.next; while(pre.next != null) { int val = pre.next.val; ListNode next = pre.next.next; ListNode pi = dummyHead; for(; pi != pre; pi = pi.next) { if(pi.next.val &gt; val) { ListNode pj = pi.next; ListNode swapNode = pre.next; pi.next = swapNode; swapNode.next = pj; pre.next = next; break; } } if(pi == pre) { pre = pre.next; } } return dummyHead.next; }} 题目来源LeetCode-147.对链表进行插入排序 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"19.删除链表的倒数第N个节点","date":"2019-11-29T16:00:00.000Z","path":"posts/4abfe71.html","text":"题目要求给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 题目示例示例: 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 解题思路需要对链表进行两次遍历 时间复杂度: O(n) 空间复杂度: O(1) 使用双指针, 对链表只遍历了一遍 时间复杂度: O(n) 空间复杂度: O(1) 1234567891011 p、q | null -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5# 将q指针进行移动n+1 p q | | null -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5# 将p找对需要删除节点4的前面 p q | | null -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 解题代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode p = dummyHead; ListNode q = dummyHead; for(int i = 0 ; i &lt; n + 1 ; i ++) { assert q != null; q = q.next; } while(q != null){ p = p.next; q = q.next; } p.next = p.next.next; return dummyHead.next; }} 题目来源LeetCode-19.删除链表的倒数第N个节点 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"237.删除链表中的节点","date":"2019-11-28T16:00:00.000Z","path":"posts/2d787bfc.html","text":"题目要求请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 – head = [4,5,1,9]，它可以表示为: 14 -&gt; 5 -&gt; 1 -&gt; 9 题目示例示例 1: 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 解题思路12345678 node | 4 -&gt; 5 -&gt; 1 -&gt; 9 因为无法知道 1 前面的节点，也就无法知道1和9的节点，所以利用9`赋值`给1, node delNode | | 4 -&gt; 5 -&gt; 9 -&gt; 9 最后删除 delNode 时间复杂度: O(1) 空间复杂度: O(1)解题代码123456789101112131415161718/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public void deleteNode(ListNode node) { // 注意: 这个方法对尾节点不适用。题目中要求了给定的node不是尾节点 // 我们检查node.next, 如果为null则抛出异常, 确保了node不是尾节点 if(node == null || node.next == null) throw new IllegalArgumentException(\"node should be valid and can not be the tail node.\"); node.val = node.next.val; node.next = node.next.next; }} 题目来源LeetCode-237.删除链表中的节点 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"25.K个一组翻转链表","date":"2019-11-27T16:00:00.000Z","path":"posts/60ad993d.html","text":"题目要求给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 说明:你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 题目示例示例: 123给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当&nbsp;k&nbsp;= 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当&nbsp;k&nbsp;= 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 解题思路123null -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 | pre 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode pre = dummyHead; while(pre != null &amp;&amp; pre.next != null) { ListNode end = pre; int i; for(i = 0; i &lt; k &amp;&amp; end.next != null; i++) { end = end.next; } if(i != k) { break; } ListNode next = end.next; ListNode rhead = reverse(pre.next, end); ListNode tail = pre.next; pre.next = rhead; tail.next = next; pre = tail; } ListNode ret = dummyHead.next; return ret; } private ListNode reverse(ListNode head, ListNode end) { if(head == end) return head; ListNode rhead = reverse(head.next, end); head.next.next = head; return rhead; }} 题目来源LeetCode-25.K个一组翻转链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"24.两两交换链表中的节点","date":"2019-11-26T16:00:00.000Z","path":"posts/d7966566.html","text":"题目要求给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 题目示例示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 解题思路 定义虚拟头节点p，p.next节点为node1，p.next.next(node1.next)节点为node2，node2.next节点为next。 123456789 dummyHead -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; NULL | | | | p node1 node2 next**一轮之后** dummyHead -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; NULL | | | | p node1 node2 next 解题代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode swapPairs(ListNode head) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode p = dummyHead; while(p.next != null &amp;&amp; p.next.next != null) { ListNode node1 = p.next; ListNode node2 = p.next.next; ListNode next = p.next.next.next; node2.next = node1; node1.next = next; p.next = node2; p = node1; } return dummyHead.next; }} 题目来源LeetCode-24.两两交换链表中的节点 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"21.合并两个有序链表","date":"2019-11-25T16:00:00.000Z","path":"posts/afbd1d19.html","text":"题目要求将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 题目示例示例: 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路解题代码123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode cur = dummyHead; while(l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { cur.next = l1; l1 = l1.next; } else { cur.next = l2; l2 = l2.next; } cur = cur.next; } if(l1 == null) { cur.next = l2; } else { cur.next = l1; } ListNode ret = dummyHead.next; return ret; }} 题目来源LeetCode-21.合并两个有序链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"82.删除排序链表中的重复元素 II","date":"2019-11-24T16:00:00.000Z","path":"posts/746ae810.html","text":"题目要求给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 题目示例示例 1: 12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解题思路1234null -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 3 -&gt; 4 -&gt; 4 -&gt; 5 | |pre cur p 解题代码123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode pre = dummyHead; ListNode cur = pre.next; while(cur != null) { int num = 0; ListNode p = cur; while(p != null &amp;&amp; p.val == cur.val) { num++; p = p.next; } // num大于等于2时才存在重复节点 if(num &gt; 1) { pre.next = p; } else { pre = cur; } cur = p; } return dummyHead.next; }} 题目来源LeetCode-82.删除排序链表中的重复元素 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"203.移除链表元素","date":"2019-11-23T16:00:00.000Z","path":"posts/39a10742.html","text":"题目要求删除链表中等于给定值 val 的所有结点。 题目示例示例 1: 12输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 解题思路第一种: 不用虚拟头结点解法 注意 由于头结点存在为空,或者只有一个结点的情况，我们无法知道链表的结点的数量。所以要将头部与中间分开判断 先删除链表头的结点 while循环头结点,判断 头结点不为null &amp;&amp; 头结点的值等于所传的值。删除头结点，如果头结点接下去结点的值也是等于所传的值，同样也会被删除 删除中间上的结点 先判断头部删除过后的头结点是否为null，如果是，直接放回return null; 将new一个prev也是指向head。遍历链表，如果中间prev下一结点的值等于所传的值，将那个结点进行删除。如果不是的话，将prev指向下一个结点 最后返回链表head 用虚拟头结点解法 由于有虚拟头结点的存在不需要判断特殊判断头结点 new一个为空的结点dummyHead，dummyHead下一个结点指向Head。这样就构建一个虚拟头结点。 将new一个prev也是指向dummyHead。遍历链表，如果中间prev下一结点的值等于所传的值，将那个结点进行删除。如果不是的话，将prev指向下一个结点 最后返回虚拟头结点往下的链表 dummyHead.next 链表+递归解法 先判断是否为空链表 递归头结点的下一个结点，并把要删除的值val传过去。头结点的下一个结点head.next来接收递归的结果。 判断头结点的值head.val是否等于要删除的值val。如果是的话就删除，不是的话就保留。 解题代码不用虚拟头结点解法123456789101112131415161718192021222324 public ListNode removeElements(ListNode head, int val) { while (head != null &amp;&amp; head.val == val) {// ListNode delNode = head;// head = head.next;// delNode.next = null; head = head.next; } if (head == null) return null; ListNode cur = head; while (cur.next != null){ if (cur.next.val == val){// ListNode delNode = cur.next;// cur.next = delNode.next;// delNode.next = null; cur.next = cur.next.next; } else { cur = cur.next; } } return head; } 用虚拟头结点解法123456789101112131415public ListNode removeElements(ListNode head, int val) { // 因为dummyHead实例的要是个null，所以传-1即可 ListNode dummyHead = new ListNode(-1); dummyHead.next = head; ListNode cur = dummyHead; while (cur.next != null){ if (cur.next.val == val){ cur.next = cur.next.next; } else { cur = cur.next; } } return dummyHead.next;} 链表+递归解法123456public ListNode removeElements(ListNode head, int val) { if (head == null) return null; head.next = removeElements(head.next, val); return head.val == val ? head.next : head;} 题目来源LeetCode-203.移除链表元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"445.两数相加 II","date":"2019-11-22T16:00:00.000Z","path":"posts/92e554b5.html","text":"题目要求给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。 您可以假设除了数字0之外，这两个数都不会以0开头。 进阶:如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 题目示例示例: 12输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出: 7 -&gt; 8 -&gt; 0 -&gt; 7 解题思路 借助两个栈，将l1、l2中的元素每次添加进栈中的第一位。 遍历两个栈，每次取出两个栈中的栈顶元素的值进行相加。 确认最后一次相加之和有没有超过9。 逆着相加，因此每次入栈总是放在栈顶 12345l1 7 -&gt; 2 -&gt; 4 -&gt; 3+ +1l2 5 -&gt; 6 -&gt; 4=ret 7 -&gt; 8 -&gt; 0 -&gt; 7 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { LinkedList&lt;Integer&gt; stack1 = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; stack2 = new LinkedList&lt;&gt;(); while(l1 != null) { stack1.addFirst(l1.val); l1 = l1.next; } while(l2 != null) { stack2.addFirst(l2.val); l2 = l2.next; } int carry = 0; ListNode ret = null; while(!stack1.isEmpty() || !stack2.isEmpty()) { int a = 0, b = 0; if(!stack1.isEmpty()) { a = stack1.removeFirst(); } if(!stack2.isEmpty()) { b = stack2.removeFirst(); } ListNode cur = new ListNode((a + b + carry) % 10); carry = (a + b + carry) / 10; cur.next = ret; ret = cur; } if(carry &gt; 0) { ListNode cur = new ListNode(carry); cur.next = ret; ret = cur; } return ret; }} 题目来源LeetCode-445.两数相加 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"2.两数相加","date":"2019-11-21T16:00:00.000Z","path":"posts/1f082419.html","text":"题目要求给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字0之外，这两个数都不会以0开头。 题目示例示例: 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路12345l1 2 -&gt; 4 -&gt; 3 +l2 5 -&gt; 6 -&gt; 4 +1ret 7 -&gt; 0 -&gt; 8 解题代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode p1 = l1; ListNode p2 = l2; ListNode dummyHead = new ListNode(0); ListNode cur = dummyHead; int carried = 0; while(p1 != null || p2 != null || carried != 0) { int a = p1 != null ? p1.val : 0; int b = p2 != null ? p2.val : 0; int sum = a + b + carried; cur.next = new ListNode(sum % 10); carried = sum / 10; cur = cur.next; p1 = p1 != null ? p1.next : null; p2 = p2 != null ? p2.next : null; } ListNode ret = dummyHead.next; return ret; }} 题目来源LeetCode-2.两数相加 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"328.奇偶链表","date":"2019-11-19T16:00:00.000Z","path":"posts/ebadf57a.html","text":"题目要求给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 说明:应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 题目示例示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 解题思路 创建两个链表，分别是奇数链表p1和偶数链表p2 从i=1开始遍历head链表，分别记录p1和p2的链表 最终p1.next指向p2即可 解题代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode oddEvenList(ListNode head) { if(head == null || head.next == null || head.next.next == null) return head; ListNode dummyHead1 = new ListNode(0); ListNode dummyHead2 = new ListNode(0); ListNode p1 = dummyHead1; ListNode p2 = dummyHead2; int i = 1; while(head != null) { if(i % 2 != 0) { p1.next = head; head = head.next; p1 = p1.next; p1.next = null; i++; } else { p2.next = head; head = head.next; p2 = p2.next; p2.next = null; i++; } } p1.next = dummyHead2.next; ListNode ret = dummyHead1.next; return ret; }} 题目来源LeetCode-328.奇偶链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"307.区域和检索 - 数组可修改","date":"2019-11-07T16:00:00.000Z","path":"posts/4fc4b822.html","text":"题目要求给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。update(i, val) 函数可以通过将下标为 i 的数值更新为 val，从而对数列进行修改。 题目示例示例 1: 12345Given nums = [1, 3, 5]sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 说明：1.数组仅可以在 update 函数下进行修改。2.你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。 解题思路 注意：这里采取自定义的线段树。更新set()和查询query()的时间复杂度都是O(log n)。 线段树的传参是泛型传参的，参入其中的参数的类型不能是基本类型。先入参数int[] nums就不符合了。所以首先将其转化成封装类Integer[]类型的数组 将转化好的Integer类型数组data传入SegmentTree线段树中，并且传一个匿名函数进去。匿名函数作用：定义同层不同父节点的节点进行相加求和。 需要在线段树上原有的基础上有set更新节点数值的方法。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124class NumArray { private SegmentTree&lt;Integer&gt; segTree; public NumArray(int[] nums) { if(nums.length &gt; 0){ Integer[] data = new Integer[nums.length]; for (int i = 0; i &lt; nums.length; i++) data[i] = nums[i]; segTree = new SegmentTree&lt;&gt;(data, (a, b) -&gt; a + b); } } public void update(int i, int val) { if(segTree == null) throw new IllegalArgumentException(\"Error\"); segTree.set(i, val); } public int sumRange(int i, int j) { if(segTree == null) throw new IllegalArgumentException(\"Segment Tree is null\"); return segTree.query(i, j); } /** * 自定义线段树 */ public interface Merger&lt;E&gt; { E merge(E a, E b); } public class SegmentTree&lt;E&gt; { private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger){ this.merger = merger; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; tree = (E[])new Object[4 * arr.length]; buildSegmentTree(0, 0, arr.length - 1); } // 在treeIndex的位置创建表示区间[l...r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r){ if(l == r){ tree[treeIndex] = data[l]; return; } int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); // int mid = (l + r) / 2; int mid = l + (r - l) / 2; buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); } // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index){ return 2*index + 1; } // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index){ return 2*index + 2; } // 返回区间[queryL, queryR]的值 public E query(int queryL, int queryR){ if(queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) throw new IllegalArgumentException(\"Index is illegal.\"); return query(0, 0, data.length - 1, queryL, queryR); } // 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 private E query(int treeIndex, int l, int r, int queryL, int queryR){ if(l == queryL &amp;&amp; r == queryR) return tree[treeIndex]; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(queryL &gt;= mid + 1) return query(rightTreeIndex, mid + 1, r, queryL, queryR); else if(queryR &lt;= mid) return query(leftTreeIndex, l, mid, queryL, queryR); E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); } // 将index位置的值，更新为e public void set(int index, E e){ if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException(\"Index is illegal\"); data[index] = e; set(0, 0, data.length - 1, index, e); } // 在以treeIndex为根的线段树中更新index的值为e private void set(int treeIndex, int l, int r, int index, E e){ if(l == r){ tree[treeIndex] = e; return; } int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(index &gt;= mid + 1) set(rightTreeIndex, mid + 1, r, index, e); else // index &lt;= mid set(leftTreeIndex, l, mid, index, e); // 更新-&gt;修改后节点的父节点的值 tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); } } } 题目来源LeetCode-307.区域和检索 - 数组可修改 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"303.区域和检索 - 数组不可变","date":"2019-11-06T16:00:00.000Z","path":"posts/32d7e4c9.html","text":"题目要求给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 题目示例示例 1: 12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明：1.你可以假设数组不可变。2.会多次调用 sumRange 方法。 解题思路数组解法思路： 定义一个数组sum来存储前i个元素的和。这里sum数组的长度需要在传入数组nums的长度上加1，因为sum[0]=0占用了一个位置。 所以求取i-j区间之和等于sum[j+1] - sum[i]之和 线段树解法思路： 注意：这里采取自定义的线段树 线段树的传参是泛型传参的，参入其中的参数的类型不能是基本类型。先入参数int[] nums就不符合了。所以首先将其转化成封装类Integer[]类型的数组 将转化好的Integer类型数组data传入SegmentTree线段树中，并且传一个匿名函数进去。匿名函数作用：定义同层不同父节点的节点进行相加求和。 解题代码数组解法：1234567891011121314151617class NumArray { private int[] sum; // sum[i]存储前i个元素和, sum[0] = 0 // 即sum[i]存储nums[0...i-1]的和 // sum(i, j) = sum[j + 1] - sum[i] public NumArray(int[] nums) { sum = new int[nums.length + 1]; sum[0] = 0; for(int i = 1; i &lt; sum.length; i++) sum[i] = sum[i - 1] + nums[i - 1]; } public int sumRange(int i, int j) { return sum[j + 1] - sum[i]; }} 线段树解法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class NumArray { public interface Merger&lt;E&gt; { E merge(E a, E b); } public class SegmentTree&lt;E&gt; { private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger){ this.merger = merger; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; tree = (E[])new Object[4 * arr.length]; buildSegmentTree(0, 0, arr.length - 1); } // 在treeIndex的位置创建表示区间[l...r]的线段树 private void buildSegmentTree(int treeIndex, int l, int r){ if(l == r){ tree[treeIndex] = data[l]; return; } int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); // int mid = (l + r) / 2; int mid = l + (r - l) / 2; buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]); } // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index){ return 2*index + 1; } // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index){ return 2*index + 2; } // 返回区间[queryL, queryR]的值 public E query(int queryL, int queryR){ if(queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) throw new IllegalArgumentException(\"Index is illegal.\"); return query(0, 0, data.length - 1, queryL, queryR); } // 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值 private E query(int treeIndex, int l, int r, int queryL, int queryR){ if(l == queryL &amp;&amp; r == queryR) return tree[treeIndex]; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(queryL &gt;= mid + 1) return query(rightTreeIndex, mid + 1, r, queryL, queryR); else if(queryR &lt;= mid) return query(leftTreeIndex, l, mid, queryL, queryR); E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult); } } private SegmentTree&lt;Integer&gt; segmentTree; public NumArray(int[] nums) { if(nums.length &gt; 0){ Integer[] data = new Integer[nums.length]; for (int i = 0; i &lt; nums.length; i++) data[i] = nums[i]; segmentTree = new SegmentTree&lt;&gt;(data, (a, b) -&gt; a + b); } } public int sumRange(int i, int j) { if(segmentTree == null) throw new IllegalArgumentException(\"Segment Tree is null\"); return segmentTree.query(i, j); }} 题目来源LeetCode-303.区域和检索 - 数组不可变 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"804.唯一摩尔斯密码词","date":"2019-11-05T16:00:00.000Z","path":"posts/2e090ffe.html","text":"题目要求 国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 “-…”, “c” 对应 “-.-.”, 等等。为了方便，所有26个英文字母对应摩尔斯密码表如下：12[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] 给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-..–…”，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。 题目示例123456789输入: words = [\"gin\", \"zen\", \"gig\", \"msg\"]输出: 2解释: 各单词翻译如下:\"gin\" -&gt; \"--...-.\"\"zen\" -&gt; \"--...-.\"\"gig\" -&gt; \"--...--.\"\"msg\" -&gt; \"--...--.\"共有 2 种不同翻译, \"--...-.\" 和 \"--...--.\". 注意: 单词列表words 的长度不会超过 100。 每个单词 words[i]的长度范围为 [1, 12]。 每个单词 words[i]只包含小写字母。 解题思路 本题要求的是返回所有词不同单词翻译的数量。而有些不同单词却有相同的摩尔斯密码。 首先我们先将words数组中单词的摩尔斯密码转化出来。 获得到words数组中单词的所有摩尔斯密码后，将他们扔进一个集合中。在这过程中，如果两个单词的摩尔斯密码相同的话，也不会重复计算 最后集合中有多少个元素，则有个摩尔斯密码。 codes[word.charAt(i) - 'a'] char字母对应ASCII码。例如 : ‘a’-‘a’=0,’b’-‘a’= 1 解题代码123456789101112131415class Solution { public int uniqueMorseRepresentations(String[] words) { String[] codes = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"}; TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(); for (String word : words) { StringBuilder res = new StringBuilder(); for (int i = 0; i&lt;word.length(); i++) res.append(codes[word.charAt(i) - 'a']); set.add(res.toString()); } return set.size(); }} 题目来源LeetCode-804.唯一摩尔斯密码词 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"1249.移除无效的括号","date":"2019-11-04T16:00:00.000Z","path":"posts/f543bed6.html","text":"题目要求给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。 你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。 请返回任意一个合法字符串。 有效「括号字符串」应当符合以下 任意一条 要求： 空字符串或只包含小写字母的字符串可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 提示： 1 &lt;= s.length &lt;= 10^5 s[i] 可能是 ‘(‘、’)’ 或英文小写字母 题目示例示例1: 123输入：s = \"lee(t(c)o)de)\"输出：\"lee(t(c)o)de\"解释：\"lee(t(co)de)\" , \"lee(t(c)ode)\" 也是一个可行答案。 示例2: 12输入：s = \"a)b(c)d\"输出：\"ab(c)d\"。 示例3: 123输入：s = \"))((\"输出：\"\"解释：空字符串也是有效的6 示例4: 12输入：s = \"(a(b(c)d)\"输出：\"a(b(c)d)\" 解题思路借助于栈 转化成char数组 遍历char数组，判断当前元素为(直接入栈;判断当前元素为)并且当前栈为空，把)替换成’ ‘，否则将栈顶元素出栈 遍历栈，将栈中的所有元素都替换成’ ‘ 将操作后的字符重新拼成String，再将’ ‘全部替换成””。 解题代码1234567891011121314151617181920212223class Solution { public String minRemoveToMakeValid(String s) { Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); char[] ch = s.toCharArray(); for(int i = 0; i &lt; ch.length; i++){ if(ch[i] == '(') stack.push(i); if(ch[i] == ')'){ if(stack.empty()) ch[i] = ' '; else stack.pop(); } } while(!stack.empty()) ch[stack.pop()] = ' '; String ret = new String(ch); ret = ret.replaceAll(\" \",\"\"); return ret; }} 题目来源LeetCode-1249.移除无效的括号 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"1239.串联字符串的最大长度","date":"2019-10-30T16:00:00.000Z","path":"posts/281222d1.html","text":"题目要求给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。 请返回所有可行解 s 中最长长度。 提示： 1 &lt;= arr.length &lt;= 16 1 &lt;= arr[i].length &lt;= 26 arr[i] 中只含有小写英文字母 题目示例示例1: 123输入：arr = [\"un\",\"iq\",\"ue\"]输出：4解释：所有可能的串联组合是 \"\",\"un\",\"iq\",\"ue\",\"uniq\" 和 \"ique\"，最大长度为 4。 示例2: 123输入：arr = [\"cha\",\"r\",\"act\",\"ers\"]输出：6解释：可能的解答有 \"chaers\" 和 \"acters\"。 示例3: 12输入：arr = [\"abcdefghijklmnopqrstuvwxyz\"]输出：26 解题思路回溯的思路 解题代码123456789101112131415161718192021222324252627282930313233343536class Solution { private int ret; public int maxLength(List&lt;String&gt; arr) { dfs(arr, 0, new StringBuilder()); return ret; } private void dfs(List&lt;String&gt; arr, int start, StringBuilder builder) { if (!match(builder)) { return; } ret = Math.max(ret, builder.length()); int size = arr.size(); for (int i = start; i &lt; size; i++) { String s = arr.get(i); builder.append(s); dfs(arr, i + 1, builder); builder.delete(builder.length() - s.length(), builder.length()); } } private boolean match(StringBuilder builder) { String s = builder.toString(); int[] count = new int[26]; for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); count[c - 97]++; if (count[c - 97] &gt; 1) { return false; } } return true; }} 题目来源LeetCode-1239.串联字符串的最大长度 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"86.分隔链表","date":"2019-10-20T16:00:00.000Z","path":"posts/998c3b7d.html","text":"题目要求给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 题目示例示例: 12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题思路解题代码12345678910111213/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode partition(ListNode head, int x) { }} 题目来源LeetCode-86.分隔链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"83.删除排序链表中的重复元素","date":"2019-10-20T16:00:00.000Z","path":"posts/2c538a68.html","text":"题目要求给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 题目示例示例 1: 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2: 12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 解题思路判断下一个节点的值是否等于当前节点的值，若是，将下一个节点进行跳过 解题代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null || head.next == null) return head; ListNode cur = head; while(cur != null) { ListNode next = cur.next; if(next != null &amp;&amp; cur.val == next.val) { cur.next = next.next; } else { cur = cur.next; } } return head; }} 题目来源LeetCode-83.删除排序链表中的重复元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"1234.替换子串得到平衡字符串","date":"2019-10-19T16:00:00.000Z","path":"posts/dd95a6d2.html","text":"题目要求有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。 假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。 给你一个这样的字符串 s，请通过「替换子串」的方式，使原字符串 s 变成一个「平衡字符串」。 你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。 请返回待替换子串的最小可能长度。 如果原字符串自身就是一个平衡字符串，则返回 0。 题目示例示例1: 123输入：s = \"QWER\"输出：0解释：s 已经是平衡的了。 示例2: 123输入：s = \"QQWE\"输出：1解释：我们需要把一个 'Q' 替换成 'R'，这样得到的 \"RQWE\" (或 \"QRWE\") 是平衡的。 示例3: 123输入：s = \"QQQW\"输出：2解释：我们可以把前面的 \"QQ\" 替换成 \"ER\"。 示例4: 123输入：s = \"QQQQ\"输出：3解释：我们可以替换后 3 个 'Q'，使 s = \"QWER\"。 解题思路滑动窗口的应用 本题只需要窗口外每种字符的数目小于等于平均值即可 解题代码123456789101112131415161718192021222324252627282930313233class Solution { public int balancedString(String s) { int[] count = new int[26]; int len = s.length(); for (int i = 0; i &lt; len; i++) { count[s.charAt(i) - 'A']++; } int left = 0, right = 0; int res = len; int average = len / 4; while (right &lt; len) { //滑动窗口里进来一个元素 就把count里的这个值减1 count[s.charAt(right) - 'A']--; //如果四个元素都符合要求 就计算最小值 while (left &lt; len &amp;&amp; count['Q' - 'A'] &lt;= average &amp;&amp; count['W' - 'A'] &lt;= average &amp;&amp; count['E' - 'A'] &lt;= average &amp;&amp; count['R' - 'A'] &lt;= average) { res = Math.min(res, right - left + 1); //移动左指针 看能不能缩小范围 count[s.charAt(left) - 'A']++; left++; } right++; } return res; }} 题目来源LeetCode-1234.替换子串得到平衡字符串 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"92.反转链表 II","date":"2019-10-17T16:00:00.000Z","path":"posts/3c5ad999.html","text":"题目要求反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 题目示例示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解题思路解题代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 1; i &lt; m; i++){ pre = pre.next; } head = pre.next; for(int i = m; i &lt; n; i++){ ListNode nex = head.next; head.next = nex.next; nex.next = pre.next; pre.next = nex; } return dummy.next; }} 题目来源LeetCode-92.反转链表 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"linked List","slug":"linked-List","permalink":"https://algo.zeffon.cn/tags/linked-List/"}]},{"title":"206.反转链表","date":"2019-10-16T16:00:00.000Z","path":"posts/b54aa585.html","text":"题目要求反转一个单链表。 题目示例示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶：你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路迭代 利用三个指针，pre指向null，cur指向当前，next指向下一个 遍历链表，先将下一个指针next定义出来，进行cur的next指向pre（进行反转）。然后pre指向cur，cur指向next。 遍历完成后，返回pre链表。 时间复杂度: O(n) 空间复杂度: O(1)递归 解题代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { /* public class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } */ public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode cur = head; while( cur != null) { ListNode next = cur.next; cur.next = pre; // 进行反转 pre = cur; cur = next; } return pre; }} 题目来源LeetCode-206.反转链表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"217.存在重复元素","date":"2019-10-15T16:00:00.000Z","path":"posts/3b41bd8.html","text":"题目要求给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 题目示例示例 1: 12输入: [1,2,3,1]输出: true 示例 2: 12输入: [1,2,3,4]输出: false 示例 3: 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解题思路 查找表 + 滑动窗口 定义HashSet查找表map 循环遍历nums数组，如果当前元素在map中存在，表示在窗口范围内是有效的， 返回true。如果不存在，则把元素添加进map中。 遍历完成，没有满足的话，返回false 时间复杂度: O(n) 空间复杂度: O(k) 解题代码123456789101112131415// 时间复杂度: O(n)// 空间复杂度: O(k)class Solution { public boolean containsDuplicate(int[] nums) { if(nums == null || nums.length &lt;= 1) return false; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++) { if(set.contains(nums[i])) return true; set.add(nums[i]); } return false; }} 题目来源LeetCode-217.存在重复元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"220.存在重复元素 III","date":"2019-10-15T16:00:00.000Z","path":"posts/3e40add0.html","text":"题目要求给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值不超过 t，并且 i 和 j 之间的差的绝对值不超过 k。 题目示例示例 1: 12输入: nums = [1,2,3,1], k = 3, t = 0输出: true 示例 2: 12输入: nums = [1,0,1,1], k = 1, t = 2输出: true 示例 3: 12输入: nums = [1,5,9,1,5,9], k = 2, t = 3输出: false 解题思路 查找表 + 滑动窗口 定义TreeSet查找表map，以k + 1长度为滑动窗口 循环遍历nums数组，如果当前元素在map中存在，表示在窗口范围内是有效的， 返回true。如果不存在，则把元素添加进map中。再判断map的大小是否等于k+1(形成一个滑动窗口，保持map中最多有k个元素),如果满足，将窗口（从左到右）的第一个元素去除。 遍历完成，没有满足的话，返回false 时间复杂度: O(nlogk) 空间复杂度: O(k) 解题代码1234567891011121314151617181920// 时间复杂度: O(nlogk)// 空间复杂度: O(k)class Solution { public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) { // 这个问题的测试数据在使用int进行加减运算时会溢出 // 所以使用long TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++) { // 查找表中是否有大于等于 nums[i] - t 且小于等于 nums[i] + t 的值 if(set.ceiling((long)nums[i] - (long)t) != null &amp;&amp; set.ceiling((long)nums[i] - (long)t) &lt;= (long)nums[i] + (long)t) { return true; } set.add((long)nums[i]); if(set.size() == k + 1) set.remove((long)nums[i-k]); } return false; }} 题目来源LeetCode-220.存在重复元素 III document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"219.存在重复元素 II","date":"2019-10-14T16:00:00.000Z","path":"posts/e2647b52.html","text":"题目要求给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值不超过 k。 题目示例示例 1: 12输入: nums = [1,2,3,1], k = 3输出: true 示例 2: 12输入: nums = [1,0,1,1], k = 1输出: true 示例 3: 12输入: nums = [1,2,3,1,2,3], k = 2输出: false 解题思路 查找表 + 滑动窗口 定义HashSet查找表map，以k + 1长度为滑动窗口 循环遍历nums数组，如果当前元素在map中存在，表示在窗口范围内是有效的， 返回true。如果不存在，则把元素添加进map中。再判断map的大小是否等于k+1(形成一个滑动窗口，保持map中最多有k个元素),如果满足，将窗口（从左到右）的第一个元素去除。 遍历完成，没有满足的话，返回false 时间复杂度: O(n) 空间复杂度: O(k) 解题代码1234567891011121314151617181920// 时间复杂度: O(n)// 空间复杂度: O(k)class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { if(nums == null || nums.length &lt;= 1) return false; if(k &lt;= 0) return false; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++) { if(set.contains(nums[i])) return true; set.add(nums[i]); // 保持set中最多有k个元素 if(set.size() == k + 1) set.remove(nums[i - k]); } return false; }} 题目来源LeetCode-219.存在重复元素 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"447.回旋镖的数量","date":"2019-10-13T16:00:00.000Z","path":"posts/32f329b6.html","text":"题目要求给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。 找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。 题目示例示例 1: 12345678输入:[[0,0],[1,0],[2,0]]输出:2解释:两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 解题思路 定义res = 0最后符合的结果有多少组 遍历二维数组，定义HashMap（两点距离为Key， 它们的频次为Value） 再次遍历二维数组，求出点i到所有其他点的距离出现的频次，并记录于HashMap中 遍历HashMap，计算符合的要求的组数。 解题代码12345678910111213141516171819202122232425262728293031// 时间复杂度: O(n^2)// 空间复杂度: O(n)class Solution { public int numberOfBoomerangs(int[][] points) { int res = 0; // 记录有多少组 for(int i = 0; i &lt; points.length; i++) { // 点i 到所有其他点的距离出现的频次 (两点距离为Key， 它们的频次为Value) HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int j = 0; j &lt; points.length; j++) { int dis = dis(points[i], points[j]); if(map.containsKey(dis)) map.put(dis, map.get(dis) + 1); else map.put(dis, 1); } for(Integer dis : map.keySet()) { // 可以忽略if(map.get(dis) &gt;= 2)判断 // 原因是不满足时，也就是为1时，是不满足题目要求不需要在res上+1的，与record.get(dis) - 1 相乘等于0 res += map.get(dis) * (map.get(dis) - 1); } } return res; } // 为了避免开根出现浮点型精确不准确的情况，利用两点间距离的平方来比较 // (AB)^2 = (x1 - x2)^2 + (y1 - y2)^2 private int dis(int[] pa, int[] pb) { return (pa[0] - pb[0])*(pa[0] - pb[0]) + (pa[1] - pb[1])*(pa[1] - pb[1]); }} 题目来源LeetCode-447.回旋镖的数量 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"1221.分割平衡字符串","date":"2019-10-12T16:00:00.000Z","path":"posts/6671a09c.html","text":"题目要求在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。 给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。 返回可以通过分割得到的平衡字符串的最大数量。 提示: 1 &lt;= s.length &lt;= 1000 s[i] = ‘L’ 或 ‘R’ 题目示例示例1: 123输入：s = \"RLRRLLRLRL\"输出：4解释：s 可以分割为 \"RL\", \"RRLL\", \"RL\", \"RL\", 每个子字符串中都包含相同数量的 'L' 和 'R'。 示例2: 123输入：s = \"RLLLLRRRLR\"输出：3解释：s 可以分割为 \"RL\", \"LLLRRR\", \"LR\", 每个子字符串中都包含相同数量的 'L' 和 'R'。 示例3: 123输入：s = \"LLLLRRRR\"输出：1解释：s 只能保持原样 \"LLLLRRRR\". 解题思路思路：将L看成-1，R看成1。定义left表示’L’相加之和，right表示’R’相加之和。记录结果res。最后有n次left、right相加之和为0，则res == n。 定义res,left,right都为0。遍历数组，判断当前元素是’L’或是’R’，进行赋值。再判断left + right 之和为0的话，res + 1，并且将left和right重新赋值为0。 最后返回res 解题代码1234567891011121314151617181920class Solution { public int balancedStringSplit(String s) { int res = 0; int left = 0, right = 0; for(int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if(c == 'L') { left += -1; } if(c == 'R') { right += 1; } if(left + right == 0) { res += 1; left = right = 0; } } return res; }} 题目来源LeetCode-1221.分割平衡字符串 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"454.四数相加 II","date":"2019-10-11T16:00:00.000Z","path":"posts/d2e697e6.html","text":"题目要求给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。 题目示例示例: 12345678910111213输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 解题思路 借助HashMap映射，以C、D数组的元素之和作为key，元素的频次作为Value。 定义map映射，遍历C数组在嵌套遍历D数组，将遍历的C、D数组的元素之和sum作为key保存在map中。如果map中已经有sum了，则在原来基础+1; 定义res为0，遍历A数组在嵌套遍历B数组, 在map中存在数组A、B的元素之和的相反值，则存在一组四数相加等于0，将res加上map中频次Value。 最后返回res。 解题代码1234567891011121314151617181920212223// 时间复杂度: O(n^2)// 空间复杂度: O(n^2)class Solution { public int fourSumCount(int[] A, int[] B, int[] C, int[] D) { if(A == null || B == null || C == null || D == null) throw new IllegalArgumentException(\"Illegal argument\"); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; C.length; i++) for(int j = 0; j &lt; D.length; j++) { int sum = C[i] + D[j]; if(map.containsKey(sum)) map.put(sum, map.get(sum) + 1); else map.put(sum, 1); } int res = 0; for(int i = 0; i &lt; A.length; i++) for(int j = 0; j &lt; B.length; j++) if(map.containsKey(0-A[i]-B[j])) res += map.get(0-A[i]-B[j]); return res; }} 题目来源LeetCode-454.四数相加 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"49.字母异位词分组","date":"2019-10-11T16:00:00.000Z","path":"posts/6c4df80a.html","text":"题目要求给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 题目示例示例: 1234567输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],输出:[ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"]] 解题思路 定义HashMap&lt;String, List&gt; map 遍历遍历数组，先将字符串s转化成char[] chars，进行字母排序后再转化成Stringkey。在map中判断key是否存在，存在的话直接根据键添加字符串s，不存在的话，将该字符串s添加进数组list中，后将key和list分别以键和值添加进map中； 定义返回数组res，遍历map，将map中的Value添加进res数组中 解题代码12345678910111213141516171819202122class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String s : strs) { char[] chars = s.toCharArray(); Arrays.sort(chars); String key = String.valueOf(chars); if(map.containsKey(key)) { map.get(key).add(s); } else { List&lt;String&gt; list = new LinkedList&lt;&gt;(); list.add(s); map.put(key, list); } } List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); for(String key: map.keySet()) { res.add(map.get(key)); } return res; }} 题目来源LeetCode-49.字母异位词分组 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"16.最接近的三数之和","date":"2019-10-10T16:00:00.000Z","path":"posts/9bc78d75.html","text":"题目要求给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 题目示例示例: 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路 先对数组nums排序(从小到大)，定义三个最小值之和作为判断标准。 遍历数组，中注意这里需要当前i指针、l指针(i + 1)、r指针(nums.length - 1)共三个指针。 随着i指针的遍历，对l、r指针控制，求出三指针之和sum。如果sum-target的绝对值比closestNum-target的绝对值还小。说明sum比closestNum更接近target，将sum赋值closestNum(刷新新的判断标准)。再判断sum==target，直接返回sum；sum &lt; target， l指针++；sum &gt; target ，r指针--。 若for循环后没有找到等于target的值，返回最接近target的closestNum。 解题代码123456789101112131415161718192021222324252627class Solution { public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int closestNum = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; nums.length - 2; i++) { int l = i + 1; int r = nums.length - 1; while(l &lt; r) { int sum = nums[i] + nums[l] + nums[r]; if(Math.abs(sum - target) &lt; Math.abs(closestNum - target)) { closestNum = sum; } if(sum == target) { return sum; } else if(sum &lt; target) { l++; } else { r--; } } } return closestNum; }} 题目来源LeetCode-16.最接近的三数之和 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"18.四数之和","date":"2019-10-09T16:00:00.000Z","path":"posts/cce02fa8.html","text":"题目要求给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 题目示例示例: 12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路123-2 -1 0 0 1 2| | | |i j l r 定义返回数组res，如果为null或者长度小于3则返回空 先对数组nums排序(从小到大) 遍历数组，中注意这里需要当前i指针、j指针(i + 1)、l指针(j + 1)、r指针(nums.length - 1)共三个指针。 随着i指针的遍历，再内部遍历j指针，对l、r指针控制，找到四指针之和等于target，将它们添加进数组res中。随后对l，r指针进行移动，并判断移动后的左右指针是否重复，重复则再移动。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(nums == null || nums.length &lt; 4) return res; Arrays.sort(nums); for(int i = 0; i &lt; nums.length - 3; i++) { if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; for(int j = i + 1; j &lt; nums.length - 2; j++) { if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue; int l = j + 1; int r = nums.length - 1; while(l &lt; r) { int sum = nums[i] + nums[j] + nums[l] + nums[r]; if(sum == target) { res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r])); l++; r--; while(l &lt; r &amp;&amp; nums[l] == nums[l - 1]) { l++; } while(l &lt; r &amp;&amp; nums[r] == nums[r + 1]) { r--; } } else if(sum &lt; target) { l++; } else { r--; } } } } return res; }} 题目来源LeetCode-18.四数之和 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"15.三数之和","date":"2019-10-08T16:00:00.000Z","path":"posts/dc9aab9f.html","text":"题目要求给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 题目示例示例: 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路 定义返回数组res，如果为null或者长度小于3则返回空 先对数组nums排序，排序后，如果最小值大于0或者最大值小于0则不可能三个数加起来等于0，直接返回空 遍历数组，中注意这里需要当前i指针、l指针(i + 1)、r指针(nums.length - 1)共三个指针。 随着i指针的遍历，对l、r指针控制，找到三指针之和为0 nums[i] + nums[l] + nums[r] == 0，将它们添加进数组res中。随后对l，r指针进行移动，并判断移动后的左右指针是否重复，重复则再移动。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(nums == null || nums.length &lt;= 2) return res; Arrays.sort(nums); if(nums[0] &gt; 0 || nums[nums.length - 1] &lt; 0) return res; for(int i = 0; i &lt; nums.length - 2; i++) { // 当不是第一个元素的时候，如果该元素和前面的元素相等则continue；删除重复 if(i != 0 &amp;&amp; nums[i] == nums[i - 1]) { continue; } int l = i + 1; int r = nums.length - 1; // 左指针小于右指针，而且当前值必须小于1，否则三个数都大于等于1. while(l &lt; r &amp;&amp; nums[i] &lt; 1) { int p = nums[i] + nums[l] + nums[r]; if(p == 0) { res.add(Arrays.asList(nums[i], nums[l], nums[r])); l++; r--; // 检查左右指针是否重复，重复则移动 while(l &lt; r &amp;&amp; nums[l] == nums[l - 1]) { l++; } while(l &lt; r &amp;&amp; nums[r] == nums[r + 1]) { r--; } } else if (p &lt; 0) { l++; } else { r--; } } } return res; } } 题目来源LeetCode-15.三数之和 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"451.根据字符出现频率排序","date":"2019-10-07T16:00:00.000Z","path":"posts/9fd1fbde.html","text":"题目要求给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 题目示例 示例 1: 123456789输入:\"tree\"输出:\"eert\"解释:'e'出现两次，'r'和't'都只出现一次。因此'e'必须出现在'r'和't'之前。此外，\"eetr\"也是一个有效的答案。 示例 2: 123456789输入:\"cccaaa\"输出:\"cccaaa\"解释:'c'和'a'都出现三次。此外，\"aaaccc\"也是有效的答案。注意\"cacaca\"是不正确的，因为相同的字母必须放在一起。 示例 3: 123456789输入:\"Aabb\"输出:\"bbAa\"解释:此外，\"bbaA\"也是一个有效的答案，但\"Aabb\"是不正确的。注意'A'和'a'被认为是两种不同的字符。 解题思路 TreeMap Key存储字母，Value字母出现频次 遍历s字符串，存储所有字母及其频次 定义优先队列(大顶堆)， 遍历哈希表，将Key添加进优先队列中。 遍历优先队列，由于频次高的先出队，并且字母会对应频次出现n次 解题代码1234567891011121314151617181920212223242526272829303132class Solution { public String frequencySort(String s) { HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) { char p = s.charAt(i); if(!map.containsKey(p)) { map.put(p, 1); } else { map.put(p, map.get(p) + 1); } } // 定义优先队列(频次大的优先) PriorityQueue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;( (a, b) -&gt; map.get(b) - map.get(a) ); // 遍历哈希表 for(char key : map.keySet()) { queue.add(key); } StringBuilder res = new StringBuilder(); while(!queue.isEmpty()) { // 遍历优先队列 char p = queue.remove(); // 频次高的先出队 for (int i = 0; i &lt; map.get(p); i++) { res.append(p); } } return res.toString(); }} 题目来源LeetCode-451.根据字符出现频率排序 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"205.同构字符串","date":"2019-10-06T16:00:00.000Z","path":"posts/2bfed2b6.html","text":"题目要求给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 说明:你可以假设 s 和 t 具有相同的长度。 题目示例 示例 1: 12输入: s = \"egg\", t = \"add\"输出: true 示例 2: 12输入: s = \"foo\", t = \"bar\"输出: false 示例 3: 12输入: s = \"paper\", t = \"title\"输出: true 解题思路解法一 HashMap将 key（s字符串字母）- value（t字符串字母）存在一起，每当遇到一个字母就去查看对应的字母。失败有两种情况： key存在，经过查找字母对应的字母和这个字母不匹配； key不存在，但是这个字母已经被存了； 解法二定义一个int[256]数组，默认值为-1和一个boolean[256]数组以ASCII表对应的为字母的索引 解题代码解法一12345678910111213141516171819202122232425class Solution { public boolean isIsomorphic(String s, String t) { if(s.length() != t.length()) return false; HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++) { char l = s.charAt(i); char r = t.charAt(i); if(map.containsKey(l)) { if(!map.get(l).equals(r)) { return false; } } else { if(map.containsValue(r)) { return false; } else { map.put(l, r); } } } return true; }} 解法二123456789101112131415161718192021222324class Solution { public boolean isIsomorphic(String s, String t) { if(s.length() != t.length()) return false; int[] map = new int[256]; Arrays.fill(map, -1); boolean[] mapped = new boolean[256]; for(int i = 0; i &lt; s.length(); i++) { char l = s.charAt(i); char r = t.charAt(i); if(map[l] == -1) { if(mapped[r]) { return false; } map[l] = r; mapped[r] = true; } else if(map[l] != r) { return false; } } return true; }} 题目来源LeetCode-205.同构字符串 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"290.单词规律","date":"2019-10-04T16:00:00.000Z","path":"posts/6735bc66.html","text":"题目要求给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 题目示例 示例 1: 12输入: pattern = \"abba\", str = \"dog cat cat dog\"输出: true 示例 2: 12输入:pattern = \"abba\", str = \"dog cat cat fish\"输出: false 示例 3: 12输入: pattern = \"aaaa\", str = \"dog cat cat dog\"输出: false 示例 4: 12输入: pattern = \"abba\", str = \"dog dog dog dog\"输出: false 解题思路 HashMap将 key（a）- value（dog）存在一起，每当遇到一个字母就去查看对应的单词。失败有两种情况： key存在，经过查找字母对应的单词和这个单词不匹配； key不存在，但是这个单词已经被存了； 解题代码12345678910111213141516171819202122232425262728class Solution { public boolean wordPattern(String pattern, String str) { if(pattern == null || str==null) return false; String[] words = str.split(\" \"); if(pattern.length() != words.length) return false; HashMap&lt;Character, String&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; pattern.length(); i++) { char p = pattern.charAt(i); if(map.containsKey(p)) { if(!map.get(p).equals(words[i])) { return false; } } else { if(map.containsValue(words[i])) { return false; } else { map.put(p, words[i]); } } } return true; }} 题目来源LeetCode-290.单词规律 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"202.快乐数","date":"2019-10-03T16:00:00.000Z","path":"posts/204bddf3.html","text":"题目要求编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 题目示例 示例:1234567输入: 19输出: true解释: 1^2 + 9^2 = 828^2 + 2^2 = 686^2 + 8^2 = 1001^2 + 0^2 + 0^2 = 1 解题思路 定义集合Set来记录每次的n值(set中n值只能是唯一一个) 解题代码12345678910111213141516171819202122232425class Solution { public boolean isHappy(int n) { HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(n); while(n != 1) { n = op(n); if(set.contains(n)) { return false; } else { set.add(n); } } return true; } private int op(int x) { int res = 0; while(x &gt; 0) { int t = x % 10; res += t * t; x /= 10; } return res; }} 题目来源LeetCode-202.快乐数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"242.有效的字母异位词","date":"2019-10-02T16:00:00.000Z","path":"posts/ffba5267.html","text":"题目要求给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 题目示例 示例 1: 12输入: s = \"anagram\", t = \"nagaram\"输出: true 示例 2: 12输入: s = \"rat\", t = \"car\"输出: false 解题思路 滑动窗口(借鉴于438的解法) 借助于’哈希表’ 定于int[26]数组为哈希表，0-26分别表示a-z。 先将s字符串中的字母遍历进哈希表中，相对应的索引进行频次++ 在遍历t字符串中的字母，若字母已在哈希表中，则相对应的索引进行频次--，后判断哈希表存在负数，则说明s与t中字母无正确异位，返回false 前面两次遍历完成，则说明s与t字母异位，返回true 解题代码解法一1234567891011121314151617181920212223242526272829303132333435class Solution { public boolean isAnagram(String s, String t) { if(s.length() != t.length()) return false; if(s.length() == 0 &amp;&amp; t.length() == 0) return true; int[] freq_t = new int[26]; for(char c : t.toCharArray()) { freq_t[c - 'a']++; } int[] freq_s = new int[26]; int l = 0, r = -1; while(r + 1 &lt; s.length()) { r++; freq_s[s.charAt(r) - 'a']++; if(r - l + 1 &gt; t.length()) { freq_s[s.charAt(l++) - 'a']--; } if(r - l + 1 == t.length() &amp;&amp; same(freq_s, freq_t)) { return true; } } return false; } private boolean same(int[] freq_s, int[] freq_p) { for(int i = 0; i &lt; 26; i++) { if(freq_s[i] != freq_p[i]) return false; } return true; }} 解法二12345678910111213141516171819// 时间复杂度 O(n)// 空间复杂度 O(26)class Solution { public boolean isAnagram(String s, String t) { if(s.length() != t.length()) return false; int[] freq = new int[26]; for(int i = 0; i &lt; s.length(); i++) { freq[s.charAt(i) - 'a']++; } for(char c : t.toCharArray()) { freq[c - 'a']--; if(freq[c - 'a'] &lt; 0) return false; } return true; }} 题目来源LeetCode-242.有效的字母异位词 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"350.两个数组的交集 II","date":"2019-10-01T16:00:00.000Z","path":"posts/60fe30bb.html","text":"题目要求给定两个数组，编写一个函数来计算它们的交集。 题目示例 示例 1: 12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2: 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明:输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。 进阶:如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解题思路 题目要求输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。所以采用Map映射来解决。 首先遍历数组1中的所有元素，把他们添加进map映射中。如果map中没有该元素，则把该元素放进map，并且标记次数1。如果map有该元素，则在该元素在map中的次数加上1。 new一个ArrayList动态数组来记录数组1和数组2共同的元素 遍历数组2的元素，判断该元素是否已经在map映射中。如果是，则把该元素加入动态数组中，并且将映射中的该元素次数减去1。再判断map中该元素的次数是否为0，是的话在map中剔除该元素 因为最后是要返回的是int[],所以以list.size()为长度new一个int[],将动态数组list中的元素遍历赋值给int[]即可，最后返回回去。 解题代码1234567891011121314151617181920212223242526272829// 时间复杂度: O(nlogn)// 空间复杂度: O(n)public class Solution { public int[] intersect(int[] nums1, int[] nums2) { TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for(int num: nums1) if(!map.containsKey(num)) map.put(num, 1); else map.put(num, map.get(num) + 1); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int num : nums2) if (map.containsKey(num) &amp;&amp; map.get(num) &gt; 0){ list.add(num); map.put(num, map.get(num) - 1); if (map.get(num) == 0) map.remove(num); } int[] res = new int[list.size()]; int index = 0; for(Integer num : list) res[index++] = num; return res; }} 题目来源LeetCode-350.两个数组的交集 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"},{"name":"map","slug":"map","permalink":"https://algo.zeffon.cn/tags/map/"}]},{"title":"349.两个数组的交集","date":"2019-09-30T16:00:00.000Z","path":"posts/7b8abb7f.html","text":"题目要求给定两个数组，编写一个函数来计算它们的交集。 题目示例 示例 1: 12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2: 12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明:输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。 解题思路 题目要求输出结果中的每个元素一定是唯一的。求的解就是两个数组的交集并且交集中的元素是唯一的。所以采用Set集合来解决。 首先遍历数组1中的所有元素，把他们添加进set集合中(根据集合的特性:不会保存重复的元素，所以这时候数组1保存在集合中的元素都是唯一的) new一个ArrayList动态数组来记录数组1和数组2共同的元素 遍历数组2的元素，判断该元素是否已经在集合中。如果是，则把该元素加入动态数组中，并且将集合中的该元素删除。这样的话，就算数组2中还有该元素，也不会进入if语句被添加到动态数组中。 因为最后是要返回的是int[],所以以list.size()为长度new一个int[],将动态数组list中的元素遍历赋值给int[]即可，最后返回回去。 解题代码12345678910111213141516171819202122// 时间复杂度: O(nlogn)// 空间复杂度: O(n)public class Solution { public int[] intersection(int[] nums1, int[] nums2) { TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for (int num:nums1){ set.add(num); } ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num: nums2){ if (set.contains(num)){ list.add(num); // 记录数组1，2都已存在的元素保存在数组list中 set.remove(num); // 去掉集合1set的已存在元素，以后遍历nums2时该元素就找不到了，也就不用进入if语句 } } int[] res = new int[list.size()]; for (int i =0; i&lt;list.size(); i++){ res[i] = list.get(i); } return res; }} 题目来源LeetCode-349.两个数组的交集 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"}]},{"title":"76.最小覆盖子串","date":"2019-09-30T05:11:29.000Z","path":"posts/4343a25b.html","text":"题目要求给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。 说明： 如果 S 中不存这样的子串，则返回空字符串 “”。如果 S 中存在这样的子串，我们保证它是唯一的答案。 题目示例 示例1: 12输入: S = \"ADOBECODEBANC\", T = \"ABC\"输出: \"BANC\" 解题思路解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { public String minWindow(String s, String t) { if(s.length() &lt; t.length()) return \"\"; int[] freq_t = new int[256]; for(char c : t.toCharArray()) { freq_t[c] ++; } int[] freq_s = new int[256]; int sCnt = 0; int minLength = s.length() + 1; int startIndex = -1; int l = 0, r = - 1; while(l &lt; s.length()) { if(r + 1 &lt; s.length() &amp;&amp; sCnt &lt; t.length()) { freq_s[s.charAt(r + 1)] ++; if(freq_s[s.charAt(r + 1)] &lt;= freq_t[s.charAt(r + 1)]) { sCnt++; } r++; } else { assert(sCnt &lt;= t.length()); if(sCnt == t.length() &amp;&amp; r - l + 1 &lt; minLength) { minLength = r -l + 1; startIndex = l; } freq_s[s.charAt(l)]--; if(freq_s[s.charAt(l)] &lt; freq_t[s.charAt(l)]) { sCnt--; } l++; } } if(startIndex != -1){ // return s.substring(startIndex, minLength); // error } return \"\"; }} 题目来源LeetCode-76.最小覆盖子串 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"438.找到字符串中所有字母异位词","date":"2019-09-29T16:00:00.000Z","path":"posts/638a8fe4.html","text":"题目要求给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明：字母异位词指字母相同，但排列不同的字符串。不考虑答案输出的顺序。 题目示例 示例1: 123456789输入:s: \"cbaebabacd\" p: \"abc\"输出:[0, 6]解释:起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。 示例2: 12345678910输入:s: \"abab\" p: \"ab\"输出:[0, 1, 2]解释:起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 解题思路 滑动窗口 定义两个int数组来储存两个字符串s、p中所包含字母的频次，初始值为0 先将p字符串中字母遍历出来，计算其字母的频次。 随着r窗边进行，计算s字符串中字母的频次。再根据窗口长度与p字符串长度的关系进行滑行。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public List&lt;Integer&gt; findAnagrams(String s, String p) { ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(s.length() &lt; p.length()) return res; int[] freq_p = new int[26]; Arrays.fill(freq_p, 0); for(char c : p.toCharArray()) { freq_p[c - 'a'] ++; } int[] freq_s = new int[26]; Arrays.fill(freq_s, 0); int l = 0, r = - 1; while(r + 1 &lt; s.length()) { r++; freq_s[s.charAt(r) - 'a'] ++; if(r - l + 1 &gt; p.length()) { freq_s[s.charAt(l++) - 'a'] --; } if(r - l + 1 == p.length() &amp;&amp; same(freq_s, freq_p)) { res.add(l); } } return res; } private boolean same(int[] freq_s, int[] freq_p) { for(int i = 0; i &lt; 26; i++) { if(freq_s[i] != freq_p[i]) return false; } return true; }} 题目来源LeetCode-438.找到字符串中所有字母异位词 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"3.无重复字符的最长子串","date":"2019-09-28T16:00:00.000Z","path":"posts/edc0eed8.html","text":"题目要求给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 题目示例 示例1: 123输入: \"abcabcbb\"输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例2: 123输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例3: 1234输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是&nbsp;\"wke\"，所以其长度为 3。&nbsp; 请注意，你的答案必须是 子串 的长度，\"pwke\"&nbsp;是一个子序列，不是子串。 解题思路 滑动窗口的思路 时间复杂度: O(n) 空间复杂度: O(1) 定义freq数组来标识ASCII码对应的存在次数（初始值为0） 定义l和r指针来表示滑动窗口为s[l…r],整个循环从 l == 0; r == -1 这个空窗口开始,到l == s.size(); r == s.size()-1 这个空窗口截止 循环遍历s字符串, 在每次循环里逐渐改变窗口, 维护freq, 并记录当前窗口中是否找到了一个新的最优值 解题代码12345678910111213141516171819class Solution { public int lengthOfLongestSubstring(String s) { int[] freq = new int[256]; int l = 0, r = -1; int res = 0; while(l &lt; s.length()) { if(r + 1 &lt; s.length() &amp;&amp; freq[s.charAt(r+1)] == 0) { r++; freq[s.charAt(r)]++; } else { freq[s.charAt(l)]--; l++; } res = Math.max(res, r - l + 1); } return res; }} 题目来源LeetCode-3.无重复字符的最长子串 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"209.长度最小的子数组","date":"2019-09-27T16:00:00.000Z","path":"posts/82979e2d.html","text":"题目要求给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 题目示例 示例: 123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶:如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路 滑动窗口的思路 时间复杂度: O(n) 空间复杂度: O(1) 解题代码123456789101112131415161718192021class Solution { public int minSubArrayLen(int s, int[] nums) { int l = 0, r = -1; // nums[l...r]为滑动窗口 int sum = 0; int res = nums.length + 1; while(l &lt; nums.length) { // 窗口的左边界在数组范围内,则循环继续 if(r + 1 &lt; nums.length &amp;&amp; sum &lt; s) { r++; sum += nums[r]; } else { sum -= nums[l]; l++; } if(sum &gt;= s) res = Math.min(res, r - l + 1); } if(res == nums.length + 1) return 0; return res; }} 题目来源LeetCode-209.长度最小的子数组 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"11.盛最多水的容器","date":"2019-09-26T16:00:00.000Z","path":"posts/626cb38d.html","text":"题目要求给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 题目示例 示例1: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路 采用双指针思路 先取最小的两边指针为高，两者间的间距为宽 取每次面积最大的保存起来，最后返回。 解题代码123456789101112131415161718class Solution { public int maxArea(int[] height) { if(height.length &lt;= 1) { return -1; } int l = 0, r = height.length - 1; int res = 0; while(l &lt; r) { int h = Math.min(height[l], height[r]); res = Math.max(res, h * (r - l)); if(height[l] &lt; height[r]) l++; else r--; } return res; }} 题目来源LeetCode-11.盛最多水的容器 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"345.反转字符串中的元音字母","date":"2019-09-25T16:00:00.000Z","path":"posts/9a0cffbb.html","text":"题目要求编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 说明:元音字母不包含字母”y”。 题目示例 示例 1: 12输入: \"hello\"输出: \"holle\" 示例 2: 12输入: \"leetcode\"输出: \"leotcede\" 解题思路 采用双指针思路 解题代码1234567891011121314151617181920212223242526272829class Solution { public String reverseVowels(String s) { if(s == null || s.length() &lt;= 1) return s; List&lt;Character&gt; vowel = Arrays.asList('a','e','i','o','u','A','E','I','O','U'); char[] arr=s.toCharArray(); int l = 0, r = s.length() - 1; while(l &lt; r) { if(!vowel.contains(arr[l])) // 如果是元音，暂停移动 l++; if(!vowel.contains(arr[r])) // 如果是元音，暂停移动 r--; if(vowel.contains(arr[l]) &amp;&amp; vowel.contains(arr[r])){// 首尾都找到元音 // 交换元音的位置 swap(arr, l, r); // 重新开始移动 l++; r--; } } return new String(arr); } private void swap(char[] ch, int i, int j) { char t = ch[i]; ch[i] = ch[j]; ch[j] = t; }} 题目来源LeetCode-345.反转字符串中的元音字母 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"344.反转字符串","date":"2019-09-24T16:00:00.000Z","path":"posts/37676658.html","text":"题目要求编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 题目示例 示例1: 12输入：[\"h\",\"e\",\"l\",\"l\",\"o\"]输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例2: 12输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 解题思路 采用对撞指针思路 解题代码12345678910111213141516class Solution { public void reverseString(char[] s) { int l = 0, r = s.length - 1; while(l &lt; r) { swap(s, l, r); l++; r--; } } private void swap(char[] ch,int i,int j){ char t = ch[i]; ch[i] = ch[j]; ch[j] = t; }} 题目来源LeetCode-344.反转字符串 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"125.验证回文串","date":"2019-09-23T16:00:00.000Z","path":"posts/b9ed2021.html","text":"题目要求给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。 题目示例 示例1: 12输入: \"A man, a plan, a canal: Panama\"输出: true 示例2: 12输入: \"race a car\"输出: false 解题思路 采用对撞指针思路 解题代码123456789101112131415161718192021222324252627282930class Solution { public boolean isPalindrome(String s) { if (s.length() &lt;= 1) return true; char[] chars = s.toLowerCase().toCharArray(); int l = 0, r = chars.length - 1; while(l &lt; r) { while(l &lt; r &amp;&amp; !isletter(chars[l])) { l++; } while(l &lt; r &amp;&amp; !isletter(chars[r])) { r--; } if(chars[l] != chars[r]) { return false; } l++; r--; } return true; } private boolean isletter(char c) { if ((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')) { return true; }else { return false; } }} 题目来源LeetCode-125.验证回文串 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"1.两数之和","date":"2019-09-22T16:00:00.000Z","path":"posts/ca1acfd.html","text":"题目要求给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 题目示例示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路 TreeMap和HashMap都可以。但是HashMap效率更优。 借助map映射，以数组的元素作为key，元素的索引作为Value。 定义map映射，遍历数组，将target - 当前遍历的元素 == 需要查找的值complement 借助于map是否找到complement，找到则返回当前i的索引以及complement的索引 找不到则将当前的元素和它的索引放进map中。 解题代码12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if(map.containsKey(complement)) int[] res = {i, map.get(complement)}; return res; map.put(nums[i], i); } throw new IllegalStateException(\"the input has no solution\"); }} 题目来源LeetCode-1.两数之和 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"lookup Table","slug":"lookup-Table","permalink":"https://algo.zeffon.cn/tags/lookup-Table/"},{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"167.两数之和 II - 输入有序数组","date":"2019-09-21T16:00:00.000Z","path":"posts/b4758439.html","text":"题目要求给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明:返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 题目示例示例: 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路解法一 采用对撞指针思路l指针为0从左边开始，r指针为numbers.length-1从右边开始。12numbers[l] + numbers[r] &lt; target -&gt; l++numbers[l] + numbers[r] &gt; target -&gt; r-- 时间复杂度: O(n) 空间复杂度: O(1) 解法二 采用二分搜索树 遍历数组， 用目标值target - 遍历的索引值获取到需要二分搜索的目标值 二分搜索控制左右边来查找的target - numbers[i]，找到返回mid索引 时间复杂度: O(nlogn) 空间复杂度: O(1) 解题代码解法一123456789101112131415161718class Solution { public int[] twoSum(int[] numbers, int target) { if(numbers.length &lt; 2) throw new IllegalArgumentException(\"Illegal argument numbers\"); int l = 0, r = numbers.length - 1; while(l &lt; r) { if(numbers[l] + numbers[r] == target) { int[] res = {l + 1, r + 1}; return res; } else if (numbers[l] + numbers[r] &lt; target) { l++; } else { r--; } } throw new IllegalStateException(\"The input has no solution\"); }} 解法二12345678910111213141516171819202122232425262728293031class Solution { public int[] twoSum(int[] numbers, int target) { if(numbers.length &lt; 2) throw new IllegalArgumentException(\"Illegal argument numbers\"); for(int i = 0 ; i &lt; numbers.length - 1 ; i ++){ int j = binarySearch(numbers, i+1, numbers.length-1, target - numbers[i]); if(j != -1){ int[] res = {i+1, j+1}; return res; } } throw new IllegalStateException(\"The input has no solution\"); } private int binarySearch(int[] nums, int l, int r, int target){ if(l &lt; 0 || l &gt; nums.length) throw new IllegalArgumentException(\"l is out of bound\"); if(r &lt; 0 || r &gt; nums.length) throw new IllegalArgumentException(\"r is out of bound\"); while(l &lt;= r){ int mid = l + (r - l)/2; if(nums[mid] == target) return mid; if(target &gt; nums[mid]) l = mid + 1; else r = mid - 1; } return -1; }} 题目来源LeetCode-167.两数之和 II - 输入有序数组 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"215.数组中的第K个最大元素","date":"2019-09-20T16:00:00.000Z","path":"posts/2f395052.html","text":"题目要求在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 注意: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 题目示例示例1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 解题思路 单路快速排序 根据partition获得的数为判断，若k-1相等则刚好是想找到的数；若小于k，则在findKthLargest(nums, l, p-1, k)中继续查找；大于k，则在findKthLargest(nums, p+1 , r, k)中继续查找。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int findKthLargest(int[] nums, int k) { if(nums == null || nums.length &lt; 0 || nums.length &lt; k){ return -1; } int n = nums.length; return findKthLargest(nums, 0, n-1, k-1); } private int findKthLargest(int[] nums, int l, int r, int k) { if(l == r) return nums[l]; int p = partition(nums, l, r); if(p == k) return nums[p]; else if(k &lt; p) return findKthLargest(nums, l, p-1, k); else return findKthLargest(nums, p+1 , r, k); } private int partition(int[] nums, int l, int r){ swap(nums , l, (int)(Math.random()*(r-l+1)) + l); int lt = l + 1; //[l+1...lt) &gt; p ; [lt..i) &lt; p for(int i = l + 1; i &lt;= r; i++) if(nums[i] &gt; nums[l]) swap(nums, i, lt++); swap(nums, l, lt - 1); return lt - 1; } private void swap(int[] nums, int i, int j){ int t = nums[i]; nums[i] = nums[j]; nums[j] = t; }} 题目来源LeetCode-215.数组中的第K个最大元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"88.合并两个有序数组","date":"2019-09-19T16:00:00.000Z","path":"posts/15739779.html","text":"题目要求给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 题目示例示例: 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出:&nbsp;[1,2,2,3,5,6] 解题思路 从后向前数组遍历 设置指针i 和 j 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 k 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充。 当 i&lt;0 时遍历结束，此时 nums2 中还有数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组 时间复杂度：O(m+n)O(m+n) 解题代码123456789101112131415161718class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int i = m -1, j = n - 1, k = m + n -1; while(i &gt;= 0 &amp;&amp; j &gt;= 0) { if(nums1[i] &gt; nums2[j]) { nums1[k] = nums1[i]; i--; } else { nums1[k] = nums2[j]; j--; } k--; } while(j &gt;= 0) { nums1[k--] = nums2[j--]; } }} 题目来源LeetCode-88.合并两个有序数组 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"75.颜色分类","date":"2019-09-18T16:00:00.000Z","path":"posts/39bfdaf1.html","text":"题目要求给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 题目示例示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路解法一利用计数排序，分别统计0、1、2的元素个数定义数组count分别记录数字0、1、2出现的次数定义变量index，表示数组nums重新排序后的索引 解法二利用三路快排的思维解决初始化zero为-1、two为nums.length，已构成两个无效的数组（0数组的终点和2数组的起点）。 12 -1 0 中间为nums nums.length-------------- zero --------------- two --------------- 最后遍历完成后的数组：[0…zero] == 0 [zero+1…two-1] == 1 [two…n-1] == 2 解题代码解法一12345678910111213141516class Solution { public void sortColors(int[] nums) { int[] count = {0, 0, 0}; // 存放0, 1, 2三个元素的频率 for(int i = 0 ; i &lt; nums.length ; i ++){ assert nums[i] &gt;= 0 &amp;&amp; nums[i] &lt;= 2; count[nums[i]] ++; } int index = 0; for(int i = 0 ; i &lt; count[0] ; i ++) nums[index++] = 0; for(int i = 0 ; i &lt; count[1] ; i ++) nums[index++] = 1; for(int i = 0 ; i &lt; count[2] ; i ++) nums[index++] = 2; }} 解法二123456789101112131415161718192021222324class Solution { public void sortColors(int[] nums) { int zero = -1; // [0...zero] == 0 int two = nums.length; // [two...n-1] == 2 for(int i = 0; i &lt; two; ) { if(nums[i] == 1) { i++; } else if(nums[i] == 2) { two--; swap(nums, i, two); } else { assert nums[i] == 0; zero++; swap(nums, zero, i); i++; } } } private static void swap(int[] arr, int i, int j) { int t = arr[i]; arr[i] = arr[j]; arr[j] = t; }} 题目来源LeetCode-75.颜色分类 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"80.删除排序数组中的重复项 II","date":"2019-09-17T16:00:00.000Z","path":"posts/a96c79e9.html","text":"题目要求给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {&nbsp; &nbsp; print(nums[i]);} 题目示例示例 1: 123给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2: 123给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为&nbsp;0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 解题思路 采用双指针的方法，由于数组是有序数组。 k指针初始值0，表示排除重复元素后所指引的位置。 i指针初始值为1，表示遍历元素所要指向的指针。 count初始值为1，表示元素出现的次数。 判断逻辑： 如果两个指针的数字不相等，先让k指针++，再让i指针覆盖k指针的值，然后保持count等于1，最后i指针++。 如果两个指针的数字相等但count大于等于2，k指针不操作，i指针++。 如果两个指针的数字相等但count为1，先将k指针++，再让i指针覆盖k指针的值，然后count++，最后i指针++。 最后返回时k+1(因为k初始值是为0)。解题代码 123456789101112131415161718192021// 时间复杂度: O(n) 空间复杂度: O(1)class Solution { public int removeDuplicates(int[] nums) { int k = 0; int count = 1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i] != nums[k]) { k++; nums[k] = nums[i]; count = 1; } else if(count &gt;= 2) { continue; } else { k++; nums[k] = nums[i]; count++; } } return k+1; }} 题目来源LeetCode-80.删除排序数组中的重复项 II document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"26.删除排序数组中的重复项","date":"2019-09-16T16:00:00.000Z","path":"posts/382a16.html","text":"题目要求给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {&nbsp; &nbsp; print(nums[i]);} 题目示例示例 1: 123给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 解题思路采用双指针的方法，由于数组是有序数组。k指针初始值0，表示排除重复元素后所指引的位置i指针初始值为1，表示遍历元素所要指向的指针最后返回时k+1(因为k初始值是为0) 解题代码123456789101112// 时间复杂度: O(n) 空间复杂度: O(1)class Solution { public int removeDuplicates(int[] nums) { int k = 0; // nums中, [0...k)的元素均为排除重复元素 for(int i = 1; i &lt; nums.length; i++){ if(nums[i] != nums[k]) k++; nums[k] = nums[i]; } return k+1; }} 题目来源LeetCode-26.删除排序数组中的重复项 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"27.移除元素","date":"2019-09-15T16:00:00.000Z","path":"posts/89234294.html","text":"题目要求给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {&nbsp; &nbsp; print(nums[i]);} 题目示例示例 1: 123给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2: 1234给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 解题思路题目要求不能借助辅助数组，避免空间消耗，借助于变量k来标识[0…k)的元素均为要删除元素，最后返回k的值即是剩余数组长度。 解题代码123456789class Solution { public int removeElement(int[] nums, int val) { int k = 0; // nums中, [0...k)的元素均为要删除元素 for(int i = 0; i &lt; nums.length; i++) if(nums[i] != val) nums[k++] = nums[i]; return k; }} 优化 123456789101112131415161718// 时间复杂度: O(n) 空间复杂度: O(1)class Solution { public int removeElement(int[] nums, int val) { int k = 0; // nums中, [0...k)的元素均为要删除元素 for(int i = 0; i &lt; nums.length; i++) if(nums[i] != val) if(k != i) swap(nums, k++, i); else k ++; return k; } private void swap(int[] nums, int i, int j){ int t = nums[i]; nums[i] = nums[j]; nums[j] = t; }} 题目来源LeetCode-27.移除元素 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"283.移动零","date":"2019-09-14T16:00:00.000Z","path":"posts/6541e420.html","text":"题目要求给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 题目示例示例 1: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 解题思路解法一把非0的元素放在一个新的动态数组nonZeroElements中，随后将nonZeroElements的元素取出来放在nums数组中，将nums剩余的位置放置为0即可 解法二不需要借助辅助数组，避免空间消耗，借助于变量k来标识[0…k)的元素均为非0元素 解题代码解法一12345678910111213141516// 时间复杂度: O(n) 空间复杂度: O(n)class Solution { public void moveZeroes(int[] nums) { ArrayList&lt;Integer&gt; nonZeroElements = new ArrayList&lt;&gt;(); // 将nums中所有非0元素放入nonZeroElements中 for(int i = 0; i &lt; nums.length; i++) if(nums[i] != 0) nonZeroElements.add(nums[i]); // 将nonZeroElements中的所有元素依次放入到nums开始的位置 for(int i = 0; i &lt; nonZeroElements.size(); i++) nums[i] = nonZeroElements.get(i); // 将nums剩余的位置放置为0 for(int i = nonZeroElements.size(); i &lt; nums.length; i++) nums[i] = 0; }} 解法二123456789101112// 时间复杂度: O(n) 空间复杂度: O(1)class Solution { public void moveZeroes(int[] nums) { int k = 0; // nums中, [0...k)的元素均为非0元素 for(int i = 0; i &lt; nums.length; i++) if(nums[i] != 0) nums[k++] = nums[i]; // 将nums剩余的位置放置为0 for(int i = k; i &lt; nums.length; i++) nums[i] = 0; }} 优化 1234567891011121314151617// 时间复杂度: O(n) 空间复杂度: O(1)class Solution { public void moveZeroes(int[] nums) { int k = 0; // nums中, [0...k)的元素均为非0元素 for(int i = 0; i &lt; nums.length; i++) if(nums[i] != 0) if(k != i) swap(nums, k++, i); else k ++; } private void swap(int[] nums, int i, int j){ int t = nums[i]; nums[i] = nums[j]; nums[j] = t; }} 题目来源LeetCode-283.移动零 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"array","slug":"array","permalink":"https://algo.zeffon.cn/tags/array/"}]},{"title":"6种常用的排序","date":"2019-09-12T16:00:00.000Z","path":"posts/84c09920.html","text":"常用排序类型Bubble Sort 冒泡排序冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。 冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 时间复杂度最坏时间复杂度 O(n^2)最优时间复杂度 O(n)平均时间复杂度 O(n^2) 简单的冒泡排序 123456789101112131415public static void bubbleSort(int [] a, int n){ for(int i=0; i&lt;n; i++){ for(int j=1; j&lt;n-i; j++){ if(arr[j-1] &gt; arr[j]){ swap(arr, j-1, j); } } }}// 交换 i, j 位置private static void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t;} 优化–面对已经排好顺序数组时的优化方案 1234567891011121314151617181920public static void bubbleSort(int [] a, int n){ int j, k = n; boolean flag = true; while (flag){ flag=false; // 如果有一趟没有发生位置交换，说明排序已经完成。 for(j=1; j&lt;k; j++){ if(a[j-1] &gt; a[j]){ swap(arr, j-1, j); flag = true; } } k--; }}// 交换 i, j 位置private static void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t;} Selection sort 选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 12345678910111213141516171819public static void sort(Comparable[] arr){ int n = arr.length; for( int i = 0 ; i &lt; n ; i ++ ){ // 寻找[i, n)区间里的最小值的索引 int minIndex = i; for( int j = i + 1 ; j &lt; n ; j ++ ) // 使用compareTo方法比较两个Comparable对象的大小 if( arr[j].compareTo( arr[minIndex] ) &lt; 0 ) minIndex = j; swap( arr , i , minIndex); }}private static void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t;} Insertion Sort 插入排序插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 123456789101112131415161718192021222324252627282930public static void sort(Comparable[] arr){ int n = arr.length; for (int i = 0; i &lt; n; i++) { // 寻找元素arr[i]合适的插入位置 // 写法1 for(int j = i ; j &gt; 0 ; j --) if(arr[j].compareTo(arr[j-1]) &lt; 0) swap( arr, j , j-1 ); else break; // 写法2 for(int j = i; j &gt; 0 &amp;&amp; arr[j].compareTo(arr[j-1]) &lt; 0 ; j--) swap(arr, j, j-1); // 写法3 Comparable e = arr[i]; for(int j = i; j &gt; 0 &amp;&amp; arr[j-1].compareTo(e) &gt; 0 ; j--) arr[j] = arr[j-1]; arr[j] = e; }}private static void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t;} Merge sort 归并排序采用分治法:分割：递归地把当前序列平均分割成两半。集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 将arr[l...mid]和arr[mid+1...r]两部分进行归并private static void merge(Comparable[] arr, int l, int mid, int r) { Comparable[] aux = Arrays.copyOfRange(arr, l, r+1); // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1 int i = l, j = mid+1; for( int k = l ; k &lt;= r; k ++ ){ if( i &gt; mid ){ // 如果左半部分元素已经全部处理完毕 arr[k] = aux[j-l]; j ++; } else if( j &gt; r ){ // 如果右半部分元素已经全部处理完毕 arr[k] = aux[i-l]; i ++; } else if( aux[i-l].compareTo(aux[j-l]) &lt; 0 ){ // 左半部分所指元素 &lt; 右半部分所指元素 arr[k] = aux[i-l]; i ++; } else{ // 左半部分所指元素 &gt;= 右半部分所指元素 arr[k] = aux[j-l]; j ++; } }}// 递归使用归并排序,对arr[l...r]的范围进行排序private static void sort(Comparable[] arr, int l, int r) { // 优化2: 对于小规模数组, 使用插入排序 if( r - l &lt;= 15 ){ InsertionSort.sort(arr, l, r); return; } // if (l &gt;= r) // return; int mid = l + (r-l)/2; // (l+r)/2 sort(arr, l, mid); sort(arr, mid + 1, r); // 优化1: 对于arr[mid] &lt;= arr[mid+1]的情况,不进行merge // 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失 if( arr[mid].compareTo(arr[mid+1]) &gt; 0 ) merge(arr, l, mid, r); // merge(arr, l, mid, r);}public static void sort(Comparable[] arr){ int n = arr.length; sort(arr, 0, n-1);} Quicksort 快速排序 快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。步骤为： 挑选基准值：从数列中挑出一个元素，称为基准（pivot）， 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成， 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。 递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。 1234567891011121314151617181920212223242526272829303132333435// 对arr[l...r]部分进行partition操作// 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p]private static int partition(Comparable[] arr, int l, int r){ Comparable v = arr[l]; int j = l; // arr[l+1...j] &lt; v ; arr[j+1...i) &gt; v for( int i = l + 1 ; i &lt;= r ; i ++ ) if( arr[i].compareTo(v) &lt; 0 ){ j ++; swap(arr, j, i); } swap(arr, l, j); return j;}// 递归使用快速排序,对arr[l...r]的范围进行排序private static void sort(Comparable[] arr, int l, int r){ if( l &gt;= r ) return; int p = partition(arr, l, r); sort(arr, l, p-1 ); sort(arr, p+1, r);}public static void sort(Comparable[] arr){ int n = arr.length; sort(arr, 0, n-1);}private static void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t;} 双路排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class QuickSort2Ways { // 双路快速排序的partition // 返回p, 使得arr[l...p-1] &lt; arr[p] ; arr[p+1...r] &gt; arr[p] private static int partition(Comparable[] arr, int l, int r){ // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot swap( arr, l , (int)(Math.random()*(r-l+1))+l ); Comparable v = arr[l]; // arr[l+1...i) &lt;= v; arr(j...r] &gt;= v int i = l+1, j = r; while( true ){ // 注意这里的边界, arr[i].compareTo(v) &lt; 0, 不能是arr[i].compareTo(v) &lt;= 0 while( i &lt;= r &amp;&amp; arr[i].compareTo(v) &lt; 0 ) i ++; // 注意这里的边界, arr[j].compareTo(v) &gt; 0, 不能是arr[j].compareTo(v) &gt;= 0 while( j &gt;= l+1 &amp;&amp; arr[j].compareTo(v) &gt; 0 ) j --; if( i &gt; j ) break; swap( arr, i, j ); i ++; j --; } swap(arr, l, j); return j; } // 递归使用快速排序,对arr[l...r]的范围进行排序 private static void sort(Comparable[] arr, int l, int r){ // 对于小规模数组, 使用插入排序 if( r - l &lt;= 15 ){ InsertionSort.sort(arr, l, r); return; } int p = partition(arr, l, r); sort(arr, l, p-1 ); sort(arr, p+1, r); } public static void sort(Comparable[] arr){ int n = arr.length; sort(arr, 0, n-1); } private static void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; }} 三路排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class QuickSort3Ways { // 递归使用快速排序,对arr[l...r]的范围进行排序 private static void sort(Comparable[] arr, int l, int r){ // 对于小规模数组, 使用插入排序 if( r - l &lt;= 15 ){ InsertionSort.sort(arr, l, r); return; } // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot swap( arr, l, (int)(Math.random()*(r-l+1)) + l ); Comparable v = arr[l]; int lt = l; // arr[l+1...lt] &lt; v int gt = r + 1; // arr[gt...r] &gt; v int i = l+1; // arr[lt+1...i) == v while( i &lt; gt ){ if( arr[i].compareTo(v) &lt; 0 ){ swap( arr, i, lt+1); i ++; lt ++; } else if( arr[i].compareTo(v) &gt; 0 ){ swap( arr, i, gt-1); gt --; } else{ // arr[i] == v i ++; } } swap( arr, l, lt ); sort(arr, l, lt-1); sort(arr, gt, r); } public static void sort(Comparable[] arr){ int n = arr.length; sort(arr, 0, n-1); } private static void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; }} Heapsort 堆排序 重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。 通常堆是通过一维数组来实现的。在数组起始位置为1的情形中： 父节点i的左子节点在位置 (2i); 父节点i的右子节点在位置 (2i+1); 子节点i的父节点在位置 （i/2); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void sort(Comparable[] arr){ int n = arr.length; // 注意，此时我们的堆是从0开始索引的 // 从(最后一个元素的索引-1)/2开始 // 最后一个元素的索引 = n-1 for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- ) shiftDown2(arr, n, i); for( int i = n-1; i &gt; 0 ; i-- ){ swap( arr, 0, i); shiftDown2(arr, i, 0); }}// 交换堆中索引为i和j的两个元素private static void swap(Object[] arr, int i, int j){ Object t = arr[i]; arr[i] = arr[j]; arr[j] = t;}// 原始的shiftDown过程private static void shiftDown(Comparable[] arr, int n, int k){ while( 2*k+1 &lt; n ){ int j = 2*k+1; if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 ) j += 1; if( arr[k].compareTo(arr[j]) &gt;= 0 )break; swap( arr, k, j); k = j; }}// 优化的shiftDown过程, 使用赋值的方式取代不断的swapprivate static void shiftDown2(Comparable[] arr, int n, int k){ Comparable e = arr[k]; while( 2*k+1 &lt; n ){ int j = 2*k+1; if( j+1 &lt; n &amp;&amp; arr[j+1].compareTo(arr[j]) &gt; 0 ) j += 1; if( e.compareTo(arr[j]) &gt;= 0 ) break; arr[k] = arr[j]; k = j; } arr[k] = e;} 总结 原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。 | 类型 | 平均时间复杂度 | 原地排序 | 稳定性 || :—-: | :—-: | :—-: | :—-: | :—-: || 冒泡排序 | O(n^2) | √| 稳定 || 选择排序 | O(1) | √ | 不稳定 || 插入排序 | O(n^2) | √ | 稳定 || 归并排序 | O(nlog n) | X | 稳定 || 快速排序 | O(nlog n) | √ | 不稳定 || 堆排序 | O(nlog n) | √ | 不稳定 | 参考文献 维基百科-冒泡排序 维基百科-选择排序 维基百科-插入排序 维基百科-归并排序 维基百科-快速排序 维基百科-堆排序 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://algo.zeffon.cn/tags/java/"}]},{"title":"AVL树、红黑树和哈希表","date":"2019-09-07T16:00:00.000Z","path":"posts/ce7fdf0a.html","text":"AVL 树 平衡二叉树的高度和节点数量之间的关系也是O(log n)的。 AVL树节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。 AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的AVL旋转。 失去平衡后进行的规律可归纳为下列四种情况： 右旋转(RR)12345678对节点y进行向右旋转操作，返回旋转后新的根节点x T1&lt; z &lt; T2 &lt; x &lt; T3 &lt; y &lt; T4 y x x.right = y / \\ / \\ y.left = T3 x T4 向右旋转 (y) z y / \\ - - - - - - - -&gt; / \\ / \\ z T3 T1 T2 T3 T4 / \\T1 T2 左旋转(LL)12345678对节点y进行向左旋转操作，返回旋转后新的根节点x T4 &lt; y &lt; T3 &lt; x &lt; T1 &lt; z &lt; T2 y x x.left = y / \\ / \\ y.right = T3T1 x 向左旋转 (y) y z / \\ - - - - - - - -&gt; / \\ / \\ T2 z T1 T2 T3 T4 / \\ T3 T4 LR12345678首先对x进行左旋转，转化为了LL的情况 y y / \\ / \\ x T4 向左旋转 (x) z T4 / \\ - - - - - - - -&gt; / \\ T1 z x T3 / \\ / \\ T2 T3 T1 T2 RL12345678首先对x进行右旋转，转化为了RR的情况 y y / \\ / \\T1 x 向右旋转 (x) T1 z / \\ - - - - - - - -&gt; / \\ z T4 T2 x / \\ / \\ T2 T3 T3 T4 Red black tree 红黑树红黑树等价于2-3树。红黑树是每个节点都带有颜色属性的二叉查找树 红黑树性质 : 每个节点是红色或者黑色。 根节点是黑色。 所有叶子都是黑色。 如果一个节点是红色的，那么它的孩子节点都是黑色的 从任意一个节点到叶子节点，经过的黑色节点是一样的。 性能总结 对于完全随机的数据，普通的二分搜索树很好用。缺点：极端情况退化成链表（或者高度不平衡） 对于查询较多的使用情况，AVL树很好用 红黑树牺牲了平衡性（2logn的高度），但它的统计性能更优（综合增删改查所有操作） 红黑树是保持黑平衡的二叉树。严格意义上不是平衡二叉树，最大高度: 2log n，时间复杂度: O(log n)。 红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。 红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。 扩展 java.util中的TreeMap和TreeSet基于红黑树实现的 红黑树是一种统计性能优秀的树结构，另一种是Splay Tree(伸展树)。它的局部性原理：刚被访问的内容下次高概率被再次访问。 Hash Table 哈希表哈希表概念哈希表（Hash table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。 哈希函数设计 哈希表充分表现了算法设计领域的经典思想：空间换时间 键通过函数函数得到的索引分布越均匀越好 处理冲突 链地址法：将散列到同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。 开放定址法 : 线性探测: 逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。 平方探测: 线性探测，相当于发生冲突时探测间隔 d =i^2 个单元的位置是否为空，如果为空，将地址存放进去。 二次探查: 一次散列产生哈希地址冲突，为了解决冲突，采用另外的散列函数或者对冲突结果进行处理的方法。 参考文献 维基百科-AVL树 维基百科-红黑树 维基百科-哈希表 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://algo.zeffon.cn/tags/java/"}]},{"title":"线段树、字典树和并查集","date":"2019-09-06T16:00:00.000Z","path":"posts/ddf9869e.html","text":"Segment Tree 线段树 线段树就是对于一棵二叉树，每一个节点其实存储的是每一个线段或者是一个区间相应的信息。 线段树不是完全二叉树，线段树是平衡二叉树，堆也是平衡二叉树。 完全二叉树本身就是平衡二叉树。平衡二叉树概念: 对于整棵树来说，最大的深度和最小的深度他们之间的差最多只有可能为1。 经典的线段树问题：区间染色、区间查询。用数组来实现这两个问题的话，更新和查询都是O(n)，而线段树则是O(log n)。 区间有n个元素，用数组表示的话需要4n的空间来存储。1234567890层：1 1层：2 2层：4 对于满二叉树：3层：8 h层，一共有2^h-1节点(大约是2^h)... 最后一层(h-1层)，有2^(h-1)个节点h-1层：2^(h-1) 最后一层的节点数大致等于前面所有层节点之和 如果n=2^k(满二叉树) 只需要2n的空间 最坏的情况，如果n=2^k+1 需要4n的空间 Trie 字典树 字典树是一种有序树，用于保存关联数组，其中的键通常是字符串。 字典树与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 UnionFind 并查集 在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。 对一组数据，主要支持两个动作 : Union(p, q)：将两个子集合并成同一个集合。 isConnected(p, q)：查询给定两个元素他们是否属于同一个集合。它可以被用来确定两个元素是否属于同一子集。 参考文献 维基百科-字典树Trie 维基百科-并查集UnionFind document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://algo.zeffon.cn/tags/java/"}]},{"title":"二叉堆和优先队列","date":"2019-09-04T16:00:00.000Z","path":"posts/b371eaae.html","text":"Priority Queue 优先队列 普通队列是先进先出，后进后出；优先队列的出队入队只与优先级相关 优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。 常见的场景：操作系统中任务调度（动态选择优先级最高的任务执行） 基于不同底层实现时间复杂度比较 底层数据结构 插入时间复杂度 取出时间复杂度 无序数组 O(1) O(n) 有序数组 O(n) O(1) 堆 O(log n) O(log n) Binary Heap 二叉堆 二叉堆是一棵完全二叉树，不会退化为链表。（二叉树在特殊情况从小到大排序是会退化成链表） 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第 h 层所有的节点都连续集中在最左边，这就是完全二叉树。 二叉堆中的某个节点的值总是不大于其父节点的值。若根节点是最大值则成为最大堆,反之是最小堆。 二叉堆添加元素放在最后的叶子节点，再根据与其父节点的大小进行调整位置，直到满足所有的父子节点关系。 二叉堆删除根节点元素，将根节点与最后的叶子节点进行互换，删除最后的叶子节点，再将根节点与其子节点进行比较互换位置，直到满足所有的父子节点关系。 可以使用数组存储二叉堆。根节点为0，按层排序下去。则父节点与其子节点的关系如下: 123parent(i) = (i - 1) / 2left child(i) = 2 * i + 1right child(i) = 2 * i + 2 参考文献 维基百科-优先队列 维基百科-二叉树 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://algo.zeffon.cn/tags/java/"}]},{"title":"集合和映射","date":"2019-09-02T16:00:00.000Z","path":"posts/6416fe0f.html","text":"Set 集合 集合的特点是：元素不重复，无下标。 集合的典型应用：客户统计、词汇量统计。 二分搜索树是非常好的实现集合的底层数据结构。 二分搜索树实现的集合时间复杂度平均为O(log n),链表实现的集合时间复杂度为O(n)。 多重集合中的元素可以重复 集合分类 集合分类 集合类型特性 底层数据结构的实现 有序集合 元素具有顺序性 基于搜索树的实现 无序集合 元素没有顺序性 基于哈希表的实现 集合的时间复杂度 (h表示树的高度) 操作 链表实现的集合 二分搜索树实现的集合 二分搜索树平均 增 add O(n) O(h) O(log n) 查 contains O(n) O(h) O(log n) 删 remove O(n) O(h) O(log n) Map 映射 映射主要是一对一间的对应关系。存储(键，值)数据对的数据结构(Key, Value), 根据键(Key)，寻找值(Value)。在其他语言中有着其他名称，如Python的字典dict。 二分搜索树是非常好的实现映射的底层数据结构。 映射集合中的键可以重复 映射分类 映射分类 映射类型特性 底层数据结构的实现 有序映射 键具有顺序性 基于搜索树的实现 无序映射 键没有顺序性 基于哈希表的实现 映射的时间复杂度 (h表示树的高度) 操作 链表实现的映射 二分搜索树实现的映射 二分搜索树平均 二分搜索树最差 增 add O(n) O(h) O(log n) O(n) 查 contains O(n) O(h) O(log n) O(n) 改 set O(n) O(h) O(log n) O(n) 查 get O(n) O(h) O(log n) O(n) 查 contains O(n) O(h) O(log n) O(n) Set集合与Map映射间的关系 其实集合与映射两者很大程度是相同的。如果将映射的值Value统一设置NULL，在这样看来映射也可以包装成集合。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://algo.zeffon.cn/tags/java/"}]},{"title":"Java非线性结构 - 树","date":"2019-08-30T16:00:00.000Z","path":"posts/445be2e5.html","text":"Tree 树二叉树 先介绍一下二叉树的性质 二叉树和链表一样，是动态数据结构。 二叉树具有天然递归结构 二叉树具有唯一根节点 二叉树每个节点最多有两个孩子 二叉树每个节点最多有一个父亲 没有孩子的节点称为叶子节点 二叉树不一定是满的。一个节点也是二叉树、空NULL也是二叉树 二分搜索树 二分搜索树是二叉树，不过二分搜索树需要满足如下要求: 二分搜索树的每个节点的值必须大于其左子树的所有节点的值 二分搜索树的每个节点的值必须小于其右子树的所有节点的值 每一棵子树也是二分搜索树 注意 二分搜索树存储的元素必须有可比较性。所以二分搜索树的值的类型需要可以进行比较的 二分搜索树的最小值和最大值 : 最小值 - 一直向左走(最左那个节点的值) 最大值 - 一直向右走(最右那个节点的值) 二分搜索树遍历 : 前序遍历 – 根节点 -&gt; 左节点 -&gt; 右节点 中序遍历 – 左节点 -&gt; 根节点 -&gt; 右节点 后序遍历 – 左节点 -&gt; 右节点 -&gt; 根节点 中序遍历将各个节点从小到大排序，后序遍历 – 释放内存采用栈实现前序遍历``非递归的写法，需要借助栈来标记节点 – 根节点先入栈，后出栈，再把其右、左孩子分别入栈，先出栈左孩子，然后入栈刚刚出栈节点的右、左孩子。若要出栈左节点无左右孩子，则出栈其父节点的右孩子(也就是其兄弟节点-右节点) 1234567891011121314// 二分搜索树的非递归前序遍历public void preOrderNR(){ Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()){ Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); }} 采用队列实现二分搜索树的层序遍历 – 先根节点入队，出队。把其左、右分别入队。先出对左孩子，再入对其刚刚出队节点的左右孩子。若左节点无左右孩子，则将其父节点的右孩子出队（也就是其兄弟节点-右节点）。 123456789101112131415// 二分搜索树的层序遍历public void levelOrder(){ if(root == null) return; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty()){ Node cur = q.remove(); System.out.println(cur.e); if(cur.left != null) q.add(cur.left); if(cur.right != null) q.add(cur.right); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://algo.zeffon.cn/tags/java/"}]},{"title":"Java 基础线性结构","date":"2019-08-28T16:00:00.000Z","path":"posts/b26f322.html","text":"Array 数组 Array是一种线性结构，把数据码成一排进行存放，只能存放同一种类型多个元素。 Java Array属于静态数组 Array最大的优点：快速查询。例如：arr[1] Array最好应用与索引有语意的场景。 但并非所有有语意的索引都适应于Array。有些索引如（身份证号）长度太长了导致空间被浪费。 相关操作 添加操作 删除操作 修改操作 查找操作 复杂度 O(n) O(n) 已知索引O(1);未知索引O(n) 已知索引O(1);未知索引O(n) Stack 栈 Satck是一种先进后出的线性结构。 相比数组，栈对应的操作是数组的子集，只能从一端添加元素，也只能从这一端取出元素。这一端称为栈顶。 栈只能在栈顶操作数据: 在表尾进行插入和删除操作。 栈的使用场景: 我们经常使用的Undo(撤销操作)、程序调用的系统栈、括号匹配。 相关操作 入栈 出栈 查看栈顶 查看元素数量 判断是否为空 复杂度 O(1)均摊 O(1)均摊 O(1) O(1) O(1) Queue 队列 Queue是一种先进先出的线性结构。 相比数组，队列对应的操作是数组的子集。只能从一端队尾添加元素，只能从另一端队首取出元素。 队列的分类: 数组队列、循环队列 循环队列必定是要浪费掉一个空间不能存储数据的 循环队列 队列为空 队列满 (c表示队列的容量) 条件 front == tail (tail + 1) % c == front 相关操作 入队 出队 查看队首 查看元素数量 判断是否为空 复杂度 O(1)均摊 O(n) O(1) O(1) O(1) 注意 数组队列出列的时间复杂度为O(n),而循环队列均摊下来的复杂度为O(1). LinkedList 链表 最简单、真正的动态数据结构，数据存储在节点Node中。 节点: 把数据存储在一种单独数据结构中，一部分是数据，一部分是下一个节点，最后一个节点是NULL。 链表在添加和删除中，对数据操作的顺序很重要。在中间添加时，先将该元素的前一个节点找出来。 优点: 真正的动态数据，不需要像Array、Stack、Queue处理固定容量的问题 缺点: 不适合用于索引有语意的情况，因为它丧失了随机访问数据的能力 Recursion 递归 递归 : 本质上，将原来的问题，转化为更小的同一问题 递归基本原则: 所有递归问题基本上都可以分为以下两部分 求解最基本问题（这个最基本问题是不能自动求解的，需要编写逻辑求解的） 把原问题转化成更小的问题（核心部分） 举例 : 数组求和1234Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1]) &lt;- 更小的同一问题(少了一个元素)Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1]) &lt;- 更小的同一问题(少了一个元素) . . . . . .Sum(arr[n-1...n-1]) = arr[n-1] + Sum([]) &lt;- 最基本的问题 代码12345678910111213141516public static int sum(int[] arr){ return sum(arr, 0);}// 计算arr[l...n)这个区间内所有数字的和private static int sum(int[] arr, int l){ if(l == arr.length) return 0; &lt;- 最基本的问题 return arr[l] + sum(arr, l + 1); &lt;- 更小的同一问题}public static void main(String[] args) { int[] nums = {1, 2, 3, 4, 5, 6, 7, 8}; System.out.println(sum(nums));} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"java","slug":"java","permalink":"https://algo.zeffon.cn/tags/java/"}]}]